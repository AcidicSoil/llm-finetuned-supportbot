
Cline Mastery Guide for VS Code and Cursor Users

Fully Utilizing Cline: A Step-by-Step Developer Guide
=====================================================

Cline is a powerful AI coding assistant that goes far beyond autocomplete – it can maintain memory across sessions, follow custom workflows, integrate external tools, enforce coding rules, and more[datacamp.com](https://www.datacamp.com/tutorial/cline-ai#:~:text=The%20tool%20understands%20large%20codebases,through%20Ollama%20or%20LM%20Studio)[datacamp.com](https://www.datacamp.com/tutorial/cline-ai#:~:text=,implementation%20for%20better%20task%20management). This guide will show you how to fully leverage Cline in VS Code (or any VS Code-based IDE like Cursor), with a focus on **actionable implementation** of its major features. We’ll cover setting up a persistent Memory Bank, designing automated Workflows, configuring MCP servers for external tools, authoring persistent Cline Rules, and using additional tools (mentions, checkpoints, task commands, remote browsing) to create a cohesive AI development environment. The final section provides a project scaffold tying all these features together into a practical setup for beginners and advanced users alike.

Cline Memory Bank: Persistent Project Memory
--------------------------------------------

**Figure: Cline Memory Bank file structure.** _Core documentation files (e.g. `projectbrief.md`, `productContext.md`, `systemPatterns.md`, etc.) link together to form a persistent knowledge base for your project, which Cline reads and updates to “remember” context across sessions._[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=The%20Memory%20Bank%20is%20a,your%20project%20details%20over%20time)[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=Memory%20Bank%20files%20are%20simply,complete%20picture%20of%20your%20project)

One of Cline’s most powerful capabilities is its **Memory Bank**, a structured set of markdown files that serve as the assistant’s long-term memory. The Memory Bank transforms Cline from a stateless chat into a persistent development partner that can effectively “remember” project details over time[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=What%20is%20the%20Cline%20Memory,Bank)[datacamp.com](https://www.datacamp.com/tutorial/cline-ai#:~:text=,implementation%20for%20better%20task%20management). By preserving context between sessions, you don’t have to re-explain your project each day – Cline will rebuild its understanding from these files at the start of each task[cline.bot](https://cline.bot/blog/memory-bank-how-to-make-cline-an-ai-agent-that-never-forgets#:~:text=Memory%20Bank%20is%20a%20community,settings%2C%20you%27re%20essentially%20telling%20it).

### Setting Up the Memory Bank

The Memory Bank is simply a folder in your repository (usually named `memory-bank/`) containing a standard set of markdown files. Cline expects the following core files (it will create them on first use if they don’t exist[cline.bot](https://cline.bot/blog/memory-bank-how-to-make-cline-an-ai-agent-that-never-forgets#:~:text=%3E%20,to%20understand%20the%20project%20context)):

    your-project/
    ├── memory-bank/
    │   ├── projectbrief.md      # High-level project overview and goals
    │   ├── productContext.md    # The “why” of the project (problems, use cases)
    │   ├── systemPatterns.md    # Architecture, key technical decisions & patterns
    │   ├── techContext.md       # Tech stack, libraries, dev environment, constraints
    │   ├── activeContext.md     # Current focus, recent changes, and active decisions
    │   └── progress.md          # Progress status, remaining tasks, known issues

When starting a new project, you can initialize the memory bank structure using Cline’s tools. For example, if you install the **Memory Bank MCP server** (a community extension for Cline), you can run an init command to scaffold these files automatically[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=After%20installation%20and%20building%2C%20initialize,in%20the%20project%27s%20root%20directory):

    # Clone and build the Memory Bank server (community MCP extension)
    git clone https://github.com/dazeb/cline-mcp-memory-bank.git
    cd cline-mcp-memory-bank && pnpm install && pnpm run build

    # Initialize memory bank in your project (creates memory-bank/ files)
    node build/index.js initialize_memory_bank .

After running the init, you’ll find the `memory-bank/` folder populated with the core `.md` files (each containing some template sections). You can also have Cline initialize it by simply asking in chat: _“Initialize the memory bank for this project.”_ Cline will then create the folder and files, asking you for key project details to fill in[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=Alternatively%2C%20if%20the%20server%20is,initialize%20the%20memory%20bank). Once set up, the Memory Bank is seamlessly integrated – Cline will quietly use it in the background with no further configuration needed[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=,understand%20project%20evolution).

> **Tip:** The first time you use Memory Bank in a project, provide a **project brief** – a short description of what you’re building and its goals. Cline will use this as the foundation and start asking follow-up questions to flesh out the other files[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=First)[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=%2A%20Start%20simple%20,it%20as%20your%20project%20evolves). You can update any file later as the project evolves.

### Using and Maintaining the Memory Bank

**How it works:** At the **start of each new task**, Cline will read the memory bank files to load the project context[cline.bot](https://cline.bot/blog/memory-bank-how-to-make-cline-an-ai-agent-that-never-forgets#:~:text=%3E%20,to%20understand%20the%20project%20context). For example, it reads your `projectbrief.md` to recall the project scope, `productContext.md` for user requirements, `systemPatterns.md` for architecture, etc., then combines that knowledge into the conversation context. This allows Cline to “remember” prior decisions, designs, and progress when you resume work[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=The%20Memory%20Bank%20isn%E2%80%99t%20a,its%20understanding%20of%20your%20project)[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=CRITICAL%3A%20Before%20ANY%20task%20or,Open%20questions%20and%20concerns). Throughout development, Cline will also **update** the Memory Bank as needed – typically after significant changes or when you explicitly ask it to. It will document new insights, record decisions, and update the `activeContext.md` and `progress.md` files so they stay accurate[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=)[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=After%20EVERY%20task%3A%201,Changes%20made).

**When to update:** Cline automatically creates Memory Bank updates whenever you discover new patterns or complete major changes[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=Memory%20Bank%20updates%20occur%20when%3A,When%20context%20needs%20clarification)[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=Memory%20Bank%20updates%20should%20automatically,occur%20when). You can also manually trigger an update by saying “_update memory bank_” – Cline will then review _all_ memory files (particularly the active context and progress) and incorporate the latest information[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=Start%20)[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=,based%20on%20your%20current%20needs). Best practice is to update the memory bank at logical milestones (e.g. after implementing a feature or resolving a big bug) so that the next session starts with an up-to-date understanding of the project.

> **Best Practices:** Treat the Memory Bank as living documentation. Keep the files concise and high-value – focus on design decisions, why certain approaches were taken, current blockers, etc. This helps Cline give consistent, context-aware help. For example, regularly note what part of the project you’re working on in `activeContext.md` (e.g. _“Implementing user login API – last session completed DB schema for users.”_), and update `progress.md` to reflect completed items and new TODOs[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=,Records%20key%20technical%20decisions)[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=,complete%3B%20reporting%20not%20started%E2%80%9D). These files not only guide Cline, but double as useful docs for you and your team. Remember: after any context reset, the Memory Bank is Cline’s only link to prior work – _its accuracy determines Cline’s effectiveness_[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=Note%3A%20When%20triggered%20by%20,as%20they%20track%20current%20state).

With the Memory Bank in place, Cline will preserve context across sessions. You can close VS Code on Friday and on Monday Cline will recall exactly where you left off, who the stakeholders are, what the architecture is, etc., by reading those files – no repetitive explaining needed[cline.bot](https://cline.bot/blog/memory-bank-how-to-make-cline-an-ai-agent-that-never-forgets#:~:text=Here%27s%20the%20thing%20about%20AI,gets%20amnesia%20every%20coffee%20break)[cline.bot](https://cline.bot/blog/memory-bank-how-to-make-cline-an-ai-agent-that-never-forgets#:~:text=Memory%20Bank%20is%20a%20community,settings%2C%20you%27re%20essentially%20telling%20it). This persistent memory system enables continuity even with large projects that exceed the model’s token window.

### Example Memory Bank Entry

To illustrate, here’s a snippet of what an Memory Bank file might contain (as an example for a web app project):

    **Project Name:** Inventory Management System
    **Overview:** Internal web app for managing inventory across multiple warehouses in real time. Includes barcode scanning and analytics.

    **Core Requirements:**
    - Track stock levels across locations with real-time updates.
    - Provide a dashboard for low-stock alerts and restock suggestions.
    - Include a barcode scanner interface for scanning products.

    **Out of Scope:**
    - No e-commerce or payment processing (internal use only).

This could be part of `projectbrief.md`. Other files would cover things like key technical decisions (e.g. “Using Redux for state management” in `systemPatterns.md`[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=4.%20systemPatterns.md%20,md)) or current status (e.g. “User authentication module complete; Inventory CRUD API ~80% done; Reporting not started” in `progress.md`[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=,complete%3B%20reporting%20not%20started%E2%80%9D)). By filling in these files, you give Cline a structured summary of the project. Whenever you say “_follow the custom instructions_” or start a new task, Cline will ingest this info to ground its advice and code in your project’s reality[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=The%20Memory%20Bank%20isn%E2%80%99t%20a,its%20understanding%20of%20your%20project)[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=Where%20are%20the%20memory%20bank,files%20stored).

_(Cline Memory Bank is a community-driven feature – you can implement it via custom instructions or by installing an MCP server. For most users, the MCP route is easiest: after installation, the `memory-bank` tools (like `initialize_memory_bank`, `update_context`, etc.) become available in Cline[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=%22memory,%5B%5D%20%7D%20%7D)[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=use_mcp_tool%28%27memory,or%20specific%20path). The server handles reading/writing the files. Alternatively, advanced users can embed the memory logic in a `.clinerules` or custom instruction to achieve similar results[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=Should%20I%20use%20custom%20instructions,clinerules).)_

Workflows: Automating Multi-Step Tasks
--------------------------------------

Cline **Workflows** allow you to define a series of steps that Cline will execute to accomplish a repetitive or complex process[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=Workflows%20allow%20you%20to%20define,name.md%5D%60%20in%20the%20chat). Instead of manually guiding the AI through the same sequence of actions (like running tests, reviewing code, deploying, etc.), you can script those steps once in a markdown file. Then, any time you need to run that workflow, you simply invoke it with a slash command.

**How it works:** A workflow is defined by a markdown `.md` file (saved in a designated workflows directory, typically alongside your `.clinerules` folder) that lists instructions and commands for Cline to follow[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=Workflows%20live%20alongside%20Cline%20Rules,Creating%20one%20is%20straightforward). Each step can include text for the AI (“Ask AI”) and embedded code blocks or tool directives (like shell commands, file operations, or even other AI tool calls). To run a workflow, type `/[workflow-name]` in the Cline chat – for example, if you have `deploy-service.md`, type `/deploy-service`. Cline will load that file and step through the instructions. You can also pass parameters if your workflow is designed to accept them (Cline will prompt you for any required inputs when you trigger the workflow)[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=1,any%20required%20parameters%20when%20prompted).

**Workflow capabilities:** Within a workflow file, you can leverage all of Cline’s tools and even external commands:

* **Built-in tools:** You can use special XML-like tags to call Cline’s internal tools or prompt actions. For example, `<read_file>` to have Cline read a file’s content, `<search_files>` to search within files, or `<ask_followup_question>` to interact with the user during the workflow[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=The%20real%20power%20comes%20from,You%20can)[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=%60%60%60xml%20,options%3E%20%3C%2Fask_followup_question%3E). These let the workflow branch or get confirmation.

* **Command-line steps:** You can include shell commands (in fenced `bash` code blocks) to run system tools like build scripts, Docker, Git, etc. Cline will execute them in the integrated terminal as part of the workflow.

* **MCP tools or APIs:** If you have MCP servers connected (for example, a Slack notifier or a testing tool), the workflow can call them as well (via the same tool-calling syntax). This means workflows can reach out to external services or perform API calls as needed[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=%2A%20Leverage%20Cline%E2%80%99s%20built,together%20in%20a%20specific%20sequence).

* **Chaining actions:** The real power is sequencing these actions. A workflow can run tests, gather results, ask you a question based on those results, then continue or abort based on your answer – all in one invocation.

### Creating a Workflow

To create a new workflow, add a markdown file to your workflows directory (for a project-specific workflow, use a folder in your repo, e.g. `.clinerules/workflows/`; for global, there may be a global workflows folder). The file should contain a clear sequence of steps and any commands. For example, let’s create a simple workflow to **run tests and deploy a service**:

    # deploy-service.md

    Ask AI:
    You have access to the `npm` and `docker` CLI tools. This workflow will test the project and deploy the latest build if tests pass.

    ## 1. Run the Test Suite
    ```bash
    npm install
    npm test

2\. Build & Push Docker Image
-----------------------------

    docker build -t myapp:latest .
    docker push myrepo/myapp:latest

3\. Deployment Confirmation
---------------------------

<ask\_followup\_question>
<question>Tests passed and the image is pushed. Do you want to deploy to production?</question>
<options>\["Yes, deploy now", "No, deploy later"\]</options>
</ask\_followup\_question>

4\. Deploy (if confirmed)
-------------------------

    # This step runs only if user confirmed "Yes, deploy now"
    kubectl rollout restart deployment/myapp



    In this `deploy-service.md` workflow:

    - Step 1 installs dependencies and runs tests.
    - Step 2 builds a Docker image and pushes it to a registry.
    - Step 3 uses an `<ask_followup_question>` tool to ask the user whether to proceed with deployment (giving two buttons: “Yes, deploy now” or “No, deploy later”).
    - Step 4 (the deploy command) would only execute if the user confirmed in step 3.

    To run this workflow, you would type `/deploy-service` in Cline’s chat. Cline will execute each step in order. At step 3 it will pause and prompt you with the options, then continue based on your choice. This kind of automation can save a lot of time for common operations like deployments, PR reviews, etc. In fact, the Cline team provided a **PR review workflow** example that automates fetching a PR’s details, diff, analyzing changes, and even drafting a response:contentReference[oaicite:41]{index=41}:contentReference[oaicite:42]{index=42} – you can create similar flows for code reviews, environment setup, or anything you find yourself doing frequently.

    **Focus Chain:** In addition to custom workflows you define, Cline has an automatic planning aid called **Focus Chain** that keeps the AI on track during any complex task. When you give Cline a task, it can generate a numbered to-do list of subtasks and persist this list in the context:contentReference[oaicite:43]{index=43}. As each item is completed, it checks it off and moves to the next. This isn’t just a UI feature – the focus chain items remain in Cline’s working context so it remembers what remains to be done. Focus Chain essentially acts like an auto-generated mini-workflow for your current task, ensuring that even if the conversation is long, the AI doesn’t lose sight of the remaining steps. It complements your own workflows by structuring ad-hoc tasks methodically (think of it as Cline being a diligent project manager for every request):contentReference[oaicite:44]{index=44}. You don’t need to script anything to use Focus Chain – just be aware that Cline may produce this list when appropriate, and you can rely on it to navigate complex tasks step-by-step.

    **Workflow best practices:** Keep workflow files focused and deterministic. Test them out on a sample scenario to ensure they do what you expect. You can include comments or instructions to yourself in the markdown (Cline will generally ignore text that isn’t in a code block or a tool tag, or you can prefix lines with `<!-- -->` to comment out). Use the `Ask AI` preamble at top to set the scene for the workflow if needed (as shown in the example). Also, remember that workflows can call other workflows or tasks via the `new_task` tool (though this can get advanced). Start simple – even a 3-step workflow to “run build → open browser → run tests” can save you a ton of time over repeated manual prompting.

    Once you have a library of useful workflows, they will appear in Cline’s **Workflows tab** in the UI for easy reuse (ensure your files are in the correct folder so Cline can load them). Workflows empower you to chain Cline’s actions in a safe, reviewable way – you design the game plan, and Cline executes it precisely, asking for confirmation when needed. This leads to more consistent results especially for DevOps tasks or lengthy processes, since the AI doesn’t “forget” a step or get sidetracked.

    ## MCP Servers: Extending Cline with External Tools

    Modern development often requires going beyond code in your editor – you might need to query a database, fetch an API, run cloud commands, or use custom utilities. Cline addresses this via **MCP (Model Context Protocol) servers**, which are plugins that act as intermediaries between the AI and external tools or data sources:contentReference[oaicite:45]{index=45}. Think of MCP as *“a USB-C port for AI”*: a standardized way to plug capabilities into Cline:contentReference[oaicite:46]{index=46}. By adding MCP servers, you can greatly extend what Cline can do – from browsing the web to running specialized analyses – all from the VS Code interface.

    ### Configuration and Integration

    Out of the box, Cline doesn’t include specific MCP servers (for security and modularity reasons):contentReference[oaicite:47]{index=47}. You choose and install the ones you need:

    - **MCP Marketplace (One-click Install):** The easiest way is to use Cline’s built-in MCP Marketplace interface:contentReference[oaicite:48]{index=48}:contentReference[oaicite:49]{index=49}. In VS Code, click the Cline extension icon and go to the *Marketplace* or *Discover* section under MCP Servers. There you can browse hundreds of available servers by category (for example: “Search”, “Browser-automation”, “Code analysis”, etc.):contentReference[oaicite:50]{index=50}. With one click you can install a server; Cline will automatically download it, build it (if needed), and prompt you for any API keys or config (for instance, a server for web search might require a Bing API key):contentReference[oaicite:51]{index=51}:contentReference[oaicite:52]{index=52}. Once installed, it appears in your “Installed MCPs” list.

    - **Manual from GitHub:** You can also add servers from source. Many community-created MCP servers are listed in repositories like the *official Cline MCPs* or *Awesome MCP* list:contentReference[oaicite:53]{index=53}. If you have a GitHub URL, you can ask Cline to add it. For example: *“Cline, add the MCP server from `https://github.com/modelcontextprotocol/servers/.../brave-search`”* :contentReference[oaicite:54]{index=54}. Cline will clone the repo, detect if it needs building (e.g. sees a `package.json` and runs `npm run build`), and prompt you for any configuration (like an executable path or API key):contentReference[oaicite:55]{index=55}:contentReference[oaicite:56]{index=56}. It then updates your MCP settings to include this server. You can always configure the settings manually as well (in the JSON file `cline_mcp_settings.json`) but the guided approach is simpler.

    - **Custom Servers:** If you want to write your own MCP server (for a truly custom integration), Cline provides a development protocol and even a template. Essentially, an MCP server can be any program (Node, Python, etc.) that reads JSON requests from stdin and writes JSON responses (tools/resources) to stdout (for STDIO mode):contentReference[oaicite:57]{index=57}. You’d register it in the settings with the command to launch it. Covering MCP server development is beyond this guide, but know that if you have a special internal API or system, you can wrap it as an MCP server to let Cline use it.

    After installation, each MCP server will have an entry in your Cline settings. For example, here’s what a configuration might look like with one local server and one remote server:

    ```json
    {
      "mcpServers": {
        "my-local-tool": {
          "command": "python",
          "args": ["/Users/me/mcp-servers/my_tool.py"],
          "env": { "API_KEY": "<your_api_key>" },
          "disabled": false
        },
        "browser-agent": {
          "url": "https://myserver.com/mcp",
          "headers": { "Authorization": "Bearer <token>" },
          "disabled": false
        }
      }
    }

In this JSON, `"my-local-tool"` is a server that Cline will launch locally (via STDIO transport) by running the given Python script (with an environment variable set)[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=Ask%20AI). `"browser-agent"` is an example of a remote MCP server (using SSE transport) that Cline will connect to at the given URL[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=%7B%20%22mcpServers%22%3A%20%7B%20%22remote,false). Typically, you won’t edit JSON by hand thanks to the UI, but it’s useful to understand. Each server entry can also specify an `alwaysAllow` list of tool names (meaning those tools won’t prompt for approval each time)[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=%22memory,%5B%5D%20%7D)[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=,false%20%7D%20%7D), and you can toggle a server on/off or restart it from the VS Code interface easily[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=1,the%20MCP%20server%20config%20box)[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=Enabling%20or%20Disabling%20a%20Server).

### Using MCP Tools and Scaling Up

Once a server is running, Cline auto-discovers its tools and resources. You’ll notice in the system prompt (which you can view via the “MCP Inspector”) that the AI is now aware of new capabilities. To **use an MCP tool**, you usually just ask in natural language and Cline will decide to invoke it if appropriate. For instance, if you installed a “Web Search” MCP, you could ask: “_Search the web for the latest React docs_”. Cline will identify that the web search tool can fulfill this and prompt you: “**Allow tool:** search\_web? \[Yes/No\]\*\*”. Upon approval, it executes the tool and the result (web content) is fed back into the conversation. This general flow applies to any tool – Cline handles calling it, you just approve and then see the results.

You can also directly prompt usage by saying something like “_Use the Slack notifier to post a message..._” if such a tool exists, but usually the AI will offer when relevant. If you find yourself always approving a certain tool (say a linter) and trust it, you can add it to the `alwaysAllow` list in settings so it runs without asking[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=,false). On the other hand, for dangerous tools, keep them requiring manual approval (default).

**Transport considerations:** There are two ways MCP servers run: **STDIO** (local) and **SSE** (remote streaming). Local STDIO servers run as child processes on your machine, communicating via standard input/output – this gives low latency and no network dependency[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=STDIO%20Transport). Remote SSE servers communicate over HTTP streaming, which allows the server to be hosted elsewhere (or share among a team) and handle multiple clients, at the cost of a bit more latency and requiring network access[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=SSE%20Transport). For example, you might run a heavy-duty AI model as a remote MCP on a powerful server and have Cline connect to it from your laptop. Or an MCP that needs to be shared by a team (like an internal database query service) could be deployed and accessed via SSE. Cline supports both seamlessly – you saw the config examples above for each. Choose STDIO for simple local tools and SSE for services you want to scale or host centrally[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=Used%20for%20remote%20servers%20accessed,over%20HTTP%2FHTTPS)[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=%2A%20Communicates%20via%20Server,Requires%20network%20access).

**Examples of MCP servers:** The use cases are endless. Some popular ones include: a **browser automation** server (to control a browser and scrape or test webapps), a **GitHub assistant** (to create issues/PRs or monitor CI), a **database query** tool (so Cline can answer questions from your database), cloud CLIs (AWS, GCP operations via AI), or even creative ones like controlling a robot or IoT device from Cline. The Cline docs list examples like monitoring GitHub issues, posting tweets, fetching weather data, automating Jira tickets, generating documentation, etc.[docs.cline.bot](https://docs.cline.bot/mcp/mcp-overview#:~:text=The%20potential%20of%20MCP%20servers,MCP%20servers%20can%20be%20used)[docs.cline.bot](https://docs.cline.bot/mcp/mcp-overview#:~:text=,dependencies%20based%20on%20project%20requirements). Essentially, any task that can be scripted or API-ified can be turned into an MCP tool for Cline to use. By integrating the right MCP servers, you empower the AI to act as an agent in your development workflow, all under your supervision.

> **Security:** MCP servers run code on your behalf, so only install ones you trust or that are sandboxed. Cline isolates credentials in environment variables or config for MCPs so you don’t have to paste secrets into chat[docs.cline.bot](https://docs.cline.bot/mcp/mcp-overview#:~:text=tools%2C%20prompts%2C%20and%20resources.%20,Interactions%20require%20explicit%20user%20approval). Always review what an MCP tool is about to do – Cline will describe the action and ask approval unless you opted out. This way you maintain a human-in-the-loop control, preventing unwanted side-effects[datacamp.com](https://www.datacamp.com/tutorial/cline-ai#:~:text=extension%20%20,over%20changes%20to%20your%20workspace).

In summary, MCP servers greatly extend Cline’s reach. With minimal setup, you can have Cline running your custom scripts, accessing internal systems, or performing tasks that normally require leaving VS Code. This turns Cline into a hub that coordinates all your dev tools through natural language. For instance, you could say: “_Run the load tests on the staging server_” and behind the scenes Cline might invoke a remote MCP that triggers a Jenkins job or hits an API endpoint – returning the results to you. All without leaving your coding context.

Cline Rules: Customizing AI Behavior
------------------------------------

While Cline comes with sensible defaults, every project and developer has unique preferences. **Cline Rules** let you inject your own guidelines and instructions into Cline’s system prompt on a persistent basis[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Cline%20Rules%20allow%20you%20to,or%20globally%20for%20every%20conversation). They act like a set of “house rules” that Cline will _always_ follow for your projects, so you don’t have to repeat the same instructions in every conversation. For example, you might have rules about coding style, architectural conventions, or how to handle certain files – once defined, Cline will take them into account in all its suggestions.

### Creating and Managing Rules

Rules are stored as markdown files as well. You can maintain them globally or per-project:

* A **Global Rule** applies to all conversations (good for personal preferences that span projects). These live in your user’s Documents folder (e.g. `~/Documents/Cline/Rules/` on Mac/Linux, or `Documents\Cline\Rules\` on Windows by default)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=The%20location%20of%20your%20Global,Cline%2FRules%60%20on%20some%20systems).

* A **Workspace/Project Rule** applies only to a specific project. These live in a folder (or single file) named `.clinerules` in your project’s root[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Once%20you%20save%20the%20file%3A)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=your,%E2%94%9C%E2%94%80%E2%94%80%20docs%2F%20%E2%94%94%E2%94%80%E2%94%80). Cline will automatically detect and load rules from `.clinerules/` when you open that workspace.

You can create a new rule from Cline’s UI: open the _Rules_ tab in the sidebar and click the “+” to add a rule. This opens a new markdown file where you can write the rule content[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Creating%20a%20Rule). Alternatively, use the **`/newrule`** slash command to be guided through rule creation[docs.cline.bot](https://docs.cline.bot/features/slash-commands/new-rule#:~:text=Using%20the%20). The `/newrule` command is interactive – Cline will ask you questions about what preferences you want to set (e.g. “Do you prefer verbose or concise explanations?”, “What testing frameworks do you use?”, “Any specific coding style guidelines?”)[docs.cline.bot](https://docs.cline.bot/features/slash-commands/new-rule#:~:text=When%20you%20want%20Cline%20to,consistently%20follow%20certain%20guidelines). After answering, it will generate a structured markdown file encapsulating those preferences for you to review[docs.cline.bot](https://docs.cline.bot/features/slash-commands/new-rule#:~:text=,be%20loaded%20for%20future%20conversations). Once you confirm, it saves it in your `.clinerules` directory and it becomes active[docs.cline.bot](https://docs.cline.bot/features/slash-commands/new-rule#:~:text=,be%20loaded%20for%20future%20conversations).

A rule file is just Markdown text describing the guidelines. You can organize it with headings and lists for clarity (Cline will parse the content as part of its system prompt). Here’s an example **Project Rule** file:

    # Project Guidelines

    ## Architecture Patterns
    - Follow microservice principles; each service has its own database.
    - Use RESTful API design for all new services.
    - All significant architectural decisions must be documented in `/docs/architecture.md`.

    ## Coding Style
    - Use **4-space indentation** for Python, **2-space** for JavaScript.
    - Follow PEP8 for Python code and Airbnb style guide for JavaScript.
    - Prefer clear variable names over abbreviations.

    ## Error Handling
    - All API endpoints should return structured JSON errors with an `error_code`.
    - Log all exceptions on the server with stack trace for debugging.

    ## Testing Requirements
    - Write unit tests for every bug fix (to prevent regressions).
    - Aim for > 90% coverage on critical modules (e.g. auth, payments).
    - Use pytest for Python tests and Jest for JS, with meaningful test case names.

This rule file outlines various project-specific standards: architecture, style, error handling, testing. Once this is saved as (for example) `.clinerules/01-guidelines.md` in your repo, Cline will include these instructions for every task in that workspace. If you asked Cline to write a new module, it would now **know** to apply 4-space indentation for Python, log exceptions, write tests, etc., without you explicitly stating those every time. Essentially, Cline Rules give the AI persistent context about _how you want to work_[docs.cline.bot](https://docs.cline.bot/features/slash-commands/new-rule#:~:text=,your%20preferences%20in%20every%20conversation).

**How rules are applied:** Cline automatically combines all active rules into its system prompt. If you have multiple markdown files in `.clinerules/`, it will merge them (you can prefix filenames with numbers like `01-`, `02-` to enforce order, though it’s not usually needed)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=your,work%20%E2%94%9C%E2%94%80%E2%94%80%20src%2F%20%E2%94%94%E2%94%80%E2%94%80)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Cline%20automatically%20processes%20all%20Markdown,files%20in%20a%20logical%20sequence). Global rules (if any) are applied first, then workspace-specific rules override or add to them[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=To%20make%20managing%20both%20single,this%20popover%20allows%20you%20to). The rules essentially become a single chunk of text that the model sees before any user prompt, guiding its behavior. You can verify which rules are active by looking at the Cline Rules UI popover – it will list global and project rules currently in effect[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=,file%20or). You can also toggle rules on/off from that UI if you want to temporarily disable one[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=settings%29%20and%20workspace%20rules%20%28,files%20to%20an%20existing%20folder).

**Custom rule variants:** Cline supports not only a single `.clinerules` file but an entire **rules folder system** for advanced use. As shown above, you can have multiple files in `.clinerules/` addressing different concerns (coding, documentation, current sprint, etc.)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=your,work%20%E2%94%9C%E2%94%80%E2%94%80%20src%2F%20%E2%94%94%E2%94%80%E2%94%80). Furthermore, you can maintain a **rules bank** – a repository of rule files that aren’t all active at once, but you copy in as needed[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=your,specific%20rules). For example, you might have a set of rules for Client A and another for Client B. You keep them in `clinerules-bank/clients/`, and when working on Client A’s project you copy the relevant file into `.clinerules/` and remove/switch out others[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Ask%20AI)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=,b.md%20.clinerules). This approach (outlined in Cline’s docs) is optional, but it’s a neat way to handle _contextual rule sets_. The benefits of using a folder of modular rules include easier maintenance (edit one area without touching others) and contextual activation (only use rules that matter for the current context, reducing noise)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Benefits%20of%20the%20Folder%20Approach). In practice, many teams start with one rules file and then split it as it grows, or when needing to switch sets for different projects.

**Examples of rules:** You saw a coding guideline example. Other common rules might include: _“Always comment public functions with JSDoc format”_, _“Prefer functional programming style where possible”_, _“Never directly commit to main branch, always create a PR”_, or _“When in doubt, ask me before using an insecure function.”_ Essentially, anything you find yourself repeatedly telling the AI (“don’t use eval”, “use responsive design”, “we follow TDD”) belongs in a rule. Rules can also instruct Cline on how to use tools – for example, a memory bank integration rule might say: “Before any task, read the memory-bank files; after completing a task, update the memory-bank (especially activeContext.md and progress.md)”[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=Memory%20Bank%20Integration%20Rules%3A)[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=After%20EVERY%20task%3A%201,Changes%20made). This would ensure the AI always leverages the Memory Bank. Another advanced use is to tailor Cline’s behavior per _mode_ or _phase_ – for instance, you might have a rule that only applies during planning (Plan mode) versus coding (Act mode). Cline doesn’t have an explicit conditional rule syntax, but you can write guidance like “In Plan mode, do X; In Act mode, do Y”, and because the AI knows which mode it’s in, it will follow that.

**Maintaining rules:** Since rules are just markdown files, they can be put under version control with your project. This is great for teams – you can all agree on a `.clinerules` file so everyone’s Cline behaves consistently and follows the project conventions[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=1.%20Version%20Controlled%3A%20The%20,standards%20and%20practices%20in%20code). If a rule needs updating, you update the file and everyone gets the new guidance. For personal global rules, you might keep your own notes (these aren’t versioned by Cline, but you could manually back them up). Cline’s UI provides a quick way to toggle rules if needed – say you have a rule that is not relevant for a quick experiment, you can disable it temporarily from the chat popover instead of deleting it[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Managing%20Rules%20with%20the%20Toggleable,Popover)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=settings%29%20and%20workspace%20rules%20%28,files%20to%20an%20existing%20folder). This flexibility helps when context-switching between different coding styles or projects.

To summarize, **Cline Rules give you fine-grained control over the AI’s responses and decisions**. By encoding your best practices and preferences, you ensure the AI’s output aligns with your expectations. It’s like configuring the “coding style” and “project knowledge” knobs on the AI. Use `/newrule` to quickly spin up a new rules file, or edit the markdown directly. After investing some time in good rules, many users find Cline becomes a much more reliable and personalized coding partner[docs.cline.bot](https://docs.cline.bot/features/slash-commands/new-rule#:~:text=,side%20projects%20with%20all%20my)[docs.cline.bot](https://docs.cline.bot/features/slash-commands/new-rule#:~:text=our%20existing%20codebase.%20,indentation%2C%20arrow%20functions%20everywhere%2C%20and) – because it’s now effectively trained on _your_ way of working, not just generic best practices.

Additional Tools and Features
-----------------------------

This section covers several additional Cline features and commands that enhance your workflow: **@ mentions** for injecting context, **checkpoints** for versioning and undo, handy **slash commands** for task management, and **remote browser integration** for web tasks. These tools, when used together, make Cline a more efficient and safe assistant.

### @ Mentions: Injecting Files, Errors, and URLs into Chat

Instead of copying and pasting code or error messages into your prompt, Cline lets you reference them directly with **@ mentions**. When you type `@` in the chat box, a menu appears with options to insert a reference to various content[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=Image%3A%20%40%20Mentions%20Overview). The referenced content will be pulled in automatically so the AI can see it. Cline supports a rich set of mention types[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=Available%20%40%20Mentions):

* **File mentions:** Use `@/path/to/file` to include the full content of any file in your workspace[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=File%20Mentions%20Reference%20any%20file,terminal%20to%20share%20your%20recent). For example, `@/src/utils/helpers.py` will tell Cline to grab that file’s text. This is extremely useful for discussing specific code – Cline “sees” the entire file, not just a snippet, so it has the full context (imports, surrounding code, etc.)[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=File%20Mentions%20Reference%20any%20file,terminal%20to%20share%20your%20recent).

* **Folder mentions:** Use `@/path/to/folder/` (note the trailing slash) to include all files in a directory[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=File%20Mentions%20Reference%20any%20file,terminal%20to%20share%20your%20recent). Cline will include a summary or structured listing of the folder’s contents and possibly key content from each file. This helps when you need the AI to understand how multiple files relate.

* **Problem mentions:** `@problems` inserts the list of current errors/warnings from your VS Code Problems pane[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=perfect%20for%20understanding%20complex%20interactions,terminal%20to%20share%20your%20recent). This way, if you have a compilation or linter errors, you can just drop `@problems` into the chat and Cline will see all the error messages and file locations in one go. This is great for debugging – e.g. “_I’m getting these errors: @problems. How do I fix them?_”.

* **Terminal output mentions:** `@terminal` inserts the recent output from your integrated terminal[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=files,22%2024%20Git%20Mentions%20Reference). For instance, if you run your test suite and it fails, just type `@terminal` and Cline will get the entire log (with all the coloring and formatting preserved)[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=warnings%20in%20your%20workspace,referencing%20documentation%20or%20GitHub%20issues). This is far easier than copy-pasting multiple screenfuls of log. Cline can then analyze the failure or error trace you showed it.

* **Git mentions:** `@git-changes` will include the diff of your unstaged Git changes, and `@[commit-hash]` will include the diff and message of that specific commit[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=terminal%20output,webpage%20content%2C%20perfect%20for%20referencing). This is useful for code review assistance or understanding what changed. For example: “_Given the changes @git-changes, do tests need updating?_” – Cline can see exactly what code was modified.

* **URL mentions:** You can paste any URL after `@`, like `@https://example.com/docs/api` [docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=perfect%20for%20debugging%20build%20errors,webpage%20content%2C%20perfect%20for%20referencing). Cline will fetch the web page content and include it (note: this requires the **Remote Browser** support to be configured, which we’ll discuss below). With URL mentions, you can ask questions about documentation or StackOverflow pages by just referencing the link – no manual copy needed. For example: “_According to @<https://docs.python.org/3/library/itertools.html>, how does `itertools.groupby` work?_” – Cline will fetch that page’s content and answer based on it.

These mentions **preserve formatting and full context**. So error logs remain easy to read, code retains indentation, etc., in the AI’s view[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=1.%20Eliminating%20copy,complete%20picture%20of%20your%20problem)[docs.cline.bot](https://docs.cline.bot/features/at-mentions/terminal-mentions#:~:text=command%20results,I%20just%20ask). Under the hood, Cline detects the `@...` patterns and replaces them with the actual content (encapsulated in special XML tags like `<file>` or `<terminal_output>` to delineate them) before sending the prompt to the model[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=happening%20behind%20the%20scenes%3A)[docs.cline.bot](https://docs.cline.bot/features/at-mentions/terminal-mentions#:~:text=How%20It%20Works%20Under%20the,Hood). This means you don’t use up valuable time manually describing or copying things – Cline does it instantly and accurately.

**Use cases:** @ mentions shine in scenarios like these:

* **Debugging:** “_I get this stack trace: @terminal. Here’s the function that triggers it: @/app/payment.py. What is the cause of the error?_” – Cline sees both the error and the code together.

* **Code review assistance:** “_@git-changes_ – Summarize these changes and point out any potential issues.” Cline will read the diff and provide a review.

* **Understanding large codebase:** “_Can you explain how the request flow works in the server? The main router is @/server/index.js and controllers are in @/server/controllers/_”.\* – This gives Cline multiple files to chew on.

* **Referencing documentation:** “_The spec says X (see @<https://tools.ietf.org/html/rfc1234>). Implement the function accordingly._” – Cline can read the RFC text for exact details.

By combining multiple mentions, you can give Cline a **complete picture** of a problem with minimal effort. As the docs say: you can chain several mentions in one prompt to provide all relevant context at once[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=1.%20Eliminating%20copy,complete%20picture%20of%20your%20problem). For example:

> _“I'm seeing an issue when I submit the form. The console error is @terminal. The frontend code is @/web/Form.jsx and the backend endpoint is @/api/routes/form.js. I suspect it broke after commit @abc1234. What’s wrong?”_

In one message you included the error output, the frontend component, backend route, and the commit diff – Cline can correlate all those and diagnose the issue, whereas explaining in words would be much more tedious.

**Important:** For `@urls` to work, you need to have Remote Browser support enabled (Cline can’t access the internet by itself). We’ll cover that soon – essentially you’ll connect Cline to a headless browser or an MCP that can fetch web pages. If not configured, `@url` mentions will just show an error or do nothing.

Mentions are a simple feature but drastically improve efficiency. They **eliminate copy-paste**, preserve fidelity of information, and ensure Cline has the _exact_ context you see[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=Why%20%40%20Mentions%20Matter). Make liberal use of them – whenever you think “the AI probably needs to see this file or this error”, just throw in an `@mention`. It will make Cline’s answers more accurate and save tokens by not having to summarize things yourself.

### Checkpoints: Version Control for AI Actions

As you collaborate with Cline on coding tasks, the AI may create or modify many files. **Checkpoints** are Cline’s built-in version control mechanism that saves a snapshot of your workspace after each step it takes[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Checkpoints%20automatically%20save%20snapshots%20of,experiment%20confidently%20with%20your%20code). Every time Cline uses a tool that changes code – for example, it writes to a file or executes a refactoring – it creates a hidden checkpoint. This allows you to _roll back_ to an earlier state if something goes wrong, or compare what changed.

**How it works:** Under the hood, Cline’s extension maintains a shadow Git repository where it commits changes on each step[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Cline%20creates%20a%20checkpoint%20after,These%20checkpoints). You don’t see these commits in your main repo (it doesn’t touch your actual Git history), but Cline exposes them through the UI. After a task step runs, you’ll see a **“Compare”** button in the chat next to that message – clicking it shows a diff of what files were changed at that step[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Viewing%20Changes%20%26%20Restoring). You’ll also see a **“Restore”** button next to each step in the task history[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Viewing%20Changes%20%26%20Restoring). Clicking “Restore” gives you options:

* **Restore Task and Workspace:** This reverts both the conversation _and_ all files to the state they were at that point[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=To%20restore%20to%20a%20previous,point). It’s like jumping into a time machine – Cline will forget any messages after that point and your code changes after that point are undone. Use this if you went down a wrong path and want to undo both the code and the discussion context.

* **Restore Task Only:** This reverts the conversation state to that point, but keeps the files as they are[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=1,codebase%20while%20preserving%20task%20context). Use this if, for example, you liked the code changes Cline made but the conversation got confused – you want to retry explaining without losing the edits.

* **Restore Workspace Only:** This keeps the conversation as-is but restores the files to that checkpoint[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=1,codebase%20while%20preserving%20task%20context). Use this if Cline’s recent code changes were bad, and you want to undo them, but you don’t want to lose the flow of the chat (perhaps you want to explain the issue and try a different approach). This is a common scenario: “Oops, Cline messed up the file, let me undo the file changes and then guide it differently.”

These restore options allow for very flexible recovery. For instance, if Cline’s code solution was wrong, you might restore the code but keep the chat (so you can tell it why it was wrong). Or if the code is fine but you want to ask a new question starting from an earlier context, you can restore the task only.

Cline’s checkpoint system means using the AI **does not risk messing up your project** because you can always roll back. It encourages experimentation: you can let Cline attempt bold refactors or generate large boilerplate, and if it doesn’t work out, just restore to the previous version with a click[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Use%20Cases)[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Testing%20Different%20Approaches). This safety net is especially helpful in **Auto-Approve** mode (where you let Cline execute multiple steps without manual confirmation). If a series of changes turn out problematic, you can undo them via the checkpoints list[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Using%20Auto). Essentially, checkpoints bring the benefits of Git (versioning and diff) to every AI action, integrated seamlessly.

**Using checkpoints effectively:** After any non-trivial AI change, consider clicking _Compare_ to review the diff. This shows exactly what Cline did, so you can approve it (maybe even commit it to your real repo) or spot mistakes. If something is off, use _Restore Workspace_ to undo the changes file-wise, but maybe stay in the conversation to guide Cline. If the whole approach went astray, do _Restore Task and Workspace_ to basically rewind and try a different approach from that point[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Example%3A%20If%20Cline%20makes%20changes,to%20try%20a%20different%20approach). You can also abandon an experiment entirely by restoring back to before it started. Checkpoints are stored in VS Code’s global storage, not in your repo[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Deleting%20Checkpoints). If you want to clear them, there’s a _“Delete All History”_ option which will remove all checkpoints (and task history)[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Deleting%20Checkpoints) – use with caution.

One more advanced trick: Cline’s **Message Editing** feature leverages checkpoints. If you edit an earlier user message and resubmit it, Cline can restore to the checkpoint right before that message and then replay from there with the new prompt[medium.com](https://medium.com/@balajibal/dissecting-cline-cline-context-management-260aec3d84cb#:~:text=Dissecting%20Cline%20%E2%80%94%20Cline%20Context,like%20%E2%80%9Cundo%E2%80%9D%20or%20task%20restoration)[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Relationship%20with%20Message%20Editing). This effectively allows you to correct a mistake in your question and rerun the conversation without starting over completely. It’s another way checkpoints enable _“have your cake and eat it too”_ scenario – you can tweak the past and roll forward again.

Overall, **checkpoints give you confidence and control** when using Cline. You’re never stuck with what the AI did – you have a history of every change and the ability to revert easily[reddit.com](https://www.reddit.com/r/CLine/comments/1jkzh71/is_there_no_way_to_revert_back_to_previous_chats/#:~:text=Reddit%20www.reddit.com%20%20Yes%20,place%20in%20the%20task). This encourages you to use Cline more freely, knowing you can always undo or compare. It’s highly recommended to incorporate reviewing diffs and using restore options as a normal part of your Cline workflow. It will save you from manually cleaning up any AI mistakes and will make the collaboration much more transparent.

### Useful Slash Commands (`/newtask`, `/deep-planning`, `/smol`, etc.)

We’ve already touched on a few of Cline’s **slash commands**, which are quick actions you can invoke from the chat input (by typing `/<name>`). Here’s a rundown of the most useful ones for task and context management:

* **`/newtask`:** Instantly fork off a new task (conversation) from your current one, carrying over essential context. This is extremely useful when your current chat has become too large or you want to tackle a sub-problem separately[docs.cline.bot](https://docs.cline.bot/exploring-clines-tools/new-task-tool#:~:text=As%20a%20quick%20alternative%20to,process%20using%20a%20Slash%20Command). When you type `/newtask`, Cline will suggest creating a new task and usually auto-generate a summary of the current context to preload (it might list the objectives accomplished so far and remaining goals)[docs.cline.bot](https://docs.cline.bot/exploring-clines-tools/new-task-tool#:~:text=,for%20Cline%20to%20suggest%20it). Upon confirmation, it ends the current chat and starts a fresh one with that summary in place. From there you continue with a clear context window but none of the old irrelevant discussion. In effect, it’s like a manual context window reset with memory of what’s important. Use `/newtask` proactively when you sense the conversation is hitting token limits or getting confused by too much history – it helps **eliminate context window limitations** while preserving continuity[datacamp.com](https://www.datacamp.com/tutorial/cline-ai#:~:text=,planning%20from%20implementation%20for%20better). (We’ll see in the scaffold how memory bank + newtask can be used together to seamlessly continue work.)

* **`/deep-planning`:** This command triggers an in-depth, structured planning mode for a complex feature or problem. Cline will go into a multi-step procedure: it will thoroughly investigate the requirements, possibly ask you clarifying questions, outline a detailed plan, and only then proceed to execution[docs.cline.bot](https://docs.cline.bot/features/slash-commands/deep-planning#:~:text=When%20you%20use%20%2Fdeep,features%3A%20thorough%20investigation%2C%20discussion). It’s akin to telling a senior engineer “let’s really plan this out before coding.” When you run `/deep-planning Your request...`, Cline will treat it differently than a normal prompt – typically, it might produce a four-step analysis: _1)_ read relevant files and requirements, _2)_ discuss possible approaches, _3)_ propose an implementation plan, and _4)_ optionally start executing (or wait for approval)[docs.cline.bot](https://docs.cline.bot/features/slash-commands/deep-planning#:~:text=When%20you%20use%20%2Fdeep,features%3A%20thorough%20investigation%2C%20discussion). This is great for very tricky tasks where jumping straight into code could lead to false starts. **Plan & Act mode** is already built into Cline (as discussed earlier), but `/deep-planning` explicitly invokes a thorough planning cycle up front. Many users report that starting complex tasks with `/deep-planning` yields better results and more organized solutions[x.com](https://x.com/cline/status/1956485641090564254#:~:text=Cline%20,you%20start%20with%20perfect). Use it when you have a big feature or architecture change – it forces the AI to slow down and “think” more systematically, almost like writing a design doc first.

* **`/smol`:** This funnily-named command is all about **compressing the context**. It tells Cline to summarize the current conversation and important details into a compact form, effectively freeing up space in the context window[reddit.com](https://www.reddit.com/r/CLine/comments/1k7xb81/cline_v3133_release_smol_context_compression/#:~:text=,Cline%20summarizes%20the%20conversation%2C)[x.com](https://x.com/cline/status/1927868371053294036#:~:text=Cline%20,even%20with%20smaller%20context%20models). If you’ve been chatting with Cline for a while and the task history is long, you might notice it getting close to the model’s token limit or starting to forget older messages. Typing `/smol` will make Cline produce a condensed summary of the conversation so far (covering key points, decisions, and data) and replace the full history with that summary in-memory. In practical terms, after `/smol`, earlier messages may no longer be in the prompt, but their essence will be preserved in the summary that remains. This is very useful before continuing a long session, or before adding a new large chunk of context (like reading a big file). It’s essentially on-demand context window management. (The name comes from the idea of making the conversation “smaller”). Note: in newer versions, `/smol` might also be accessible via `/compact`. After running it, you can continue the task with plenty of headroom. This works nicely in combination with checkpoints – you might checkpoint (which happens anyway) then smol to compress. Many users love `/smol` as it “frees up your context window space by generating a comprehensive summary”[datacamp.com](https://www.datacamp.com/tutorial/cline-ai#:~:text=Cline%20AI%3A%20A%20Guide%20With,This%20makes%20context), allowing very long-running assistant sessions without starting from scratch.

* **`/newrule`:** We covered this in the Rules section – it launches an interactive flow to create a new rule file. It’s a quick way to teach Cline new preferences on the fly (e.g. if mid-project you realize you want to enforce a pattern, you can /newrule and add it). This is better than just telling Cline in conversation because the rule will persist for future tasks. The use cases and an example were discussed earlier.

* **Other slash commands:** Cline has a few more, like `/reportbug` (which packages logs and info to help report an issue to the Cline team – use it if you encounter a bug with the extension), and possibly provider-specific ones. But those above are the main ones you’ll use regularly for workflow control. There are also shortcut commands like “Plan” and “Act” buttons or slash toggles to switch modes (instead of clicking the UI) – these simply do the same mode switch for Plan & Act.

Using slash commands can streamline your interactions. For instance, it’s much faster to type `/newtask` or click the “branch” icon than to manually copy-paste a summary into a new chat. And commands like `/deep-planning` and `/smol` can significantly improve outcome quality and manage costs by ensuring context is handled optimally. As a developer, think of these commands as additional tools in your toolbox – they help manage **conversation state** just like Git manages code state, keeping everything organized and efficient.

### Remote Browser Support: Letting Cline Browse the Web

Cline can even venture outside your codebase: with **Remote Browser support**, it can load and interact with webpages. This feature is particularly handy for two scenarios:

1. **Including web documentation or examples via `@url` mentions:** If you reference a URL with `@`, Cline needs a way to fetch that page’s content. Remote Browser provides that capability by controlling a browser that can download the page (including handling authentication if needed).

2. **Automating web tasks or testing a web app:** You could instruct Cline to open your local dev server in a browser, click buttons, fill forms, and report results, much like an automated QA tester. Cline can capture screenshots or console logs through this as well[github.com](https://github.com/cline/cline#:~:text=cline%2Fcline%20,allowing%20him%20to%20fix).

**How to set it up:** Remote Browser works via a headless Chrome instance. You have a few options to enable it:

* **Connect to a local Chrome:** The simplest method introduced in Cline v3.10 is to use a running Chrome/Chromium on your machine with remote debugging enabled[reddit.com](https://www.reddit.com/r/CLine/comments/1jvcuv8/cline_310_released_connect_to_local_chrome/#:~:text=Cline%203,replaces%20the%20old%20sessionless). You would launch Chrome with a command like `chrome --remote-debugging-port=9222` (or in VS Code, use the Cline command to connect to Chrome). In Cline’s MCP settings, you configure the remote browser by pointing it to `http://localhost:9222` (the debug port). Once connected, Cline can instruct that Chrome to navigate pages and perform actions. This way, when you do `@http://...`, Cline actually uses Chrome to fetch the page and returns the text.

* **Use a Browser MCP server:** There are community MCP servers (like “Browser Use Server”) designed for browser automation[glama.ai](https://glama.ai/mcp/servers/@ztobs/cline-browser-use-mcp#:~:text=Browser%20Use%20Server%20,Browser%20Operations). These are basically programs (often using Puppeteer or Playwright) that Cline can send commands to (open URL, click selector, etc.). If you prefer, you can install one of those via MCP marketplace. For example, a “Brave Browser” MCP or a generic “Browser” MCP. They might require specifying the browser binary path (as we saw in the earlier GitHub example where it asked for the Brave executable path)[docs.cline.bot](https://docs.cline.bot/mcp/adding-mcp-servers-from-github#:~:text=Cline%3A%20,Where%27s%20your%20Brave%20browser%20executable). Once set, you essentially have a tool like `open_url` or similar that Cline will use under the hood for `@url`.

* **Remote session (enterprise):** In some setups, you might run the browser on a remote machine (for example, a testing environment) and Cline connects to it. The principle is the same (SSE connection to a service that drives the browser).

For most individual developers, connecting to your local Chrome is straightforward. In the Cline UI, find _Remote Browser_ (or it might appear when you do an @ mention of an URL for the first time, guiding you to set it up). After connecting, test it by referencing a simple site (like `@https://example.com`). Cline should fetch and include the page text.

**What Cline can do with the browser:** It’s not limited to just static pages. Because it has a controlled Chrome instance, it can simulate user interactions. For example, it could fill out a login form if you provide it the steps (assuming you’ve logged in in that Chrome or provided session cookies). It can scroll, click, and capture the DOM. In effect, Cline can perform tasks akin to a Selenium script, but directed by natural language or workflow. One could say: “_Open our local app and run through the signup flow._” With a properly configured browser tool, Cline could navigate to `http://localhost:3000`, input test data, press buttons, and perhaps catch errors or take a screenshot. This is an advanced use, but it shows how the AI can extend into integration testing territory. The Cline docs mention using remote browser for certain web development test cases where authentication tokens and cookies are needed – meaning you can leverage your logged-in browser session.

**Security note:** The browser controlled by Cline is still under your supervision – it will ask before performing actions if they’re not read-only. Fetching a page to read is usually auto-approved when you trigger it via @ mention (you implicitly allowed it by using the mention). But if a workflow or the AI tries to do something like form submission, you’d see a tool approval. Also, be mindful that if you let Cline access an authenticated session, it could technically perform any action you could on that site – so only do this with test accounts or when you trust the AI in that context. The human oversight is key: you decide what tasks to allow.

In summary, enabling Remote Browser support unlocks Cline’s ability to directly incorporate external web knowledge and perform web UI operations. It’s extremely useful for pulling in documentation as context (no more copy-pasting snippets of MDN or StackOverflow – just `@<url>` it). It also opens up creative possibilities like automated UI testing or scraping within your development workflow. If your work involves web development, definitely consider setting up the remote browser feature. It turns Cline into a kind of one-stop shop where it can not only manage your code but also verify your app in a browser, search the web for solutions, and more – all with your guidance and approval.

Bringing It All Together: Project Scaffold and Workflow Integration
-------------------------------------------------------------------

We’ve covered a lot of features – now let’s outline how you can integrate them all in a cohesive developer setup. The goal is to have a project environment where Cline’s memory, rules, workflows, and tools all complement each other to assist you effectively. Below is a **recommended scaffold** for a project repository and Cline configuration that puts everything in place:

    my-project/
    ├── memory-bank/                # Persistent AI memory for this project
    │   ├── projectbrief.md         # (Filled with project overview/goals)
    │   ├── productContext.md       # (Filled with problem statement, requirements)
    │   ├── systemPatterns.md       # (Architecture decisions and patterns)
    │   ├── techContext.md          # (Tech stack and setup details)
    │   ├── activeContext.md        # (Updated frequently with current focus)
    │   └── progress.md             # (Updated with milestones, status, issues)
    ├── .clinerules/                # Project-specific Cline rules
    │   ├── 01-guidelines.md        # Coding standards, architecture rules, etc.
    │   ├── 02-memory-bank.md       # (Optional) Rule telling Cline to use/update Memory Bank
    │   ├── 03-newtask-strategy.md  # (Optional) Rule for auto new_task triggers and context block format
    │   └── workflows/             # Directory for workflow files
    │       ├── pr-review.md        # Workflow to automate pull request reviews
    │       ├── deploy-service.md   # Workflow to test & deploy (from example above)
    │       └── ... other workflows ...
    ├── src/                       # Your source code (Python/JS/Java/etc.)
    │   └── ...
    ├── tests/                     # Your tests
    │   └── ...
    └── README.md                  # (Your standard project readme)

**Memory Bank:** In this scaffold, the `memory-bank/` folder is checked into source control (so teammates also benefit from the up-to-date docs). On day one of the project, you might manually write the `projectbrief.md` (or run the `initialize_memory_bank` tool to generate templates). As development proceeds, Cline will update these files. Team members can read them like living documentation. If a new dev joins, they can read `systemPatterns.md` to quickly grasp architecture, etc. And whenever someone starts a new Cline task on this project, they simply say “follow custom instructions” and Cline will ingest these files to get up to speed[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=The%20Memory%20Bank%20isn%E2%80%99t%20a,its%20understanding%20of%20your%20project).

**Cline Rules:** The `.clinerules/` directory holds markdown files that define how Cline should behave for this project. In `01-guidelines.md` you put things like code style, definition-of-done, whatever rules matter globally. In `02-memory-bank.md`, you could include the “Memory Bank integration rules” discussed earlier – for example, a rule that says: _“Before any response, always check memory://active/context, memory://project/context, etc. After every task, update the memory files.”_[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=Memory%20Bank%20Integration%20Rules%3A)[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=After%20EVERY%20task%3A%201,Changes%20made). This will reinforce the memory bank usage in case the AI needs reminding. In `03-newtask-strategy.md`, you might define when to automatically use `new_task` – e.g. _“If context >50% full, consider summarizing and starting a new task (handoff). Always carry over summary of Completed Work, Pending Tasks, and Known Bugs in the `<context>` of new\_task.”_ (This corresponds to implementing an automatic handoff workflow like what the New Task Tool documentation suggests[docs.cline.bot](https://docs.cline.bot/exploring-clines-tools/new-task-tool#:~:text=The%20Power%20of%20,Custom%20Workflows)[docs.cline.bot](https://docs.cline.bot/exploring-clines-tools/new-task-tool#:~:text=define%20the%20%60,comprehensive%20structure%20often%20includes)). These additional rule files are **optional** and more advanced – you could also just keep one `.clinerules` file. But splitting them out as shown makes it clear what each is for, and you can toggle them individually if needed. By placing this folder in the repo, all developers get the same rules loaded (ensuring consistency in AI behavior across the team)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=1.%20Version%20Controlled%3A%20The%20,standards%20and%20practices%20in%20code). Do note that each user will need to open the project in VS Code with Cline to use them – but once they do, Cline will automatically load these rules.

**Workflows:** As shown, we suggest keeping workflow files under `.clinerules/workflows/` for project-specific workflows. For example, `pr-review.md` could contain the PR review process steps (which might use company-specific tools or standards), `deploy-service.md` we demonstrated earlier, etc. These files can also be put under version control so they evolve with the project’s needs. Cline will detect them and list them in the Workflows UI. Developers can run them with a slash command or from the UI. You might also have a `new-dev-setup.md` workflow to onboard a new developer (installs dependencies, sets up env vars, runs a test, etc.), or a `release.md` workflow to cut a new release (bump version, update changelog, tag in git, etc.). By storing them here, you essentially build a library of automation that’s one command away within Cline. It’s like documenting your processes, but in an executable form.

**MCP Servers:** While MCP configurations are typically in user-specific settings (not in the repo), you should document in the project README or wiki which MCP servers are recommended for full functionality. For example, if this project relies on a “Database Query” MCP and a “Slack Notifier” MCP, note that so team members can install them. You might even include a snippet of the `cline_mcp_settings.json` in docs to show how to configure (though don’t commit actual API keys). In our scaffold, if memory bank MCP is used, each dev would install it locally (as it’s more of a personal setup). The `.clinerules/02-memory-bank.md` rule file ensures that whether or not the MCP is installed, Cline knows it should manage those files; if the MCP is present, it provides actual tool support (like `update_memory_bank` tool), otherwise Cline will do its best with just the instructions.

**Remote Browser:** Similar to MCP, each user enables this on their machine. As an integrator, you might include a note: “For full Cline usage, connect your browser (Chrome) via remote debugging on port 9222.” If your workflows involve any `@url` or web actions (say the `pr-review.md` could fetch a GitHub PR page content via URL mention), then having the remote browser configured is important. In a corporate setting, you might even run a dedicated remote browser MCP server that developers connect to (though usually local is fine). The key is to ensure everyone has the capability so that when they run the workflow or mention a URL, it works.

**Putting it in practice:** Here’s a scenario of how all pieces come together in day-to-day work:

* _Morning:_ You open the project in VS Code and start a new Cline chat: “_Cline, let’s continue the feature from yesterday._” Before answering, Cline reads the Memory Bank files (it sees in `activeContext.md` that you were implementing the payment integration and had an issue with currency conversion)[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=The%20Memory%20Bank%20isn%E2%80%99t%20a,its%20understanding%20of%20your%20project)[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=As%20you%20work%20with%20Cline%2C,less%20accurate%2C%20it%E2%80%99s%20time%20to). It also loads the project’s rules (so it knows your coding standards and to update memory bank later)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Cline%20Rules%20allow%20you%20to,or%20globally%20for%20every%20conversation)[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=CRITICAL%3A%20Before%20ANY%20task%20or,Open%20questions%20and%20concerns). It greets you with a summary: “Good morning! Yesterday we were working on payment integration and identified an issue with currency conversion rounding. Our next step is to fix that in `PaymentService` (per activeContext). Let’s proceed in Plan mode.” This response is possible because of the persistent context provided by memory + rules.

* _Implementing a fix:_ You discuss the approach in Plan mode. Cline follows your rule to be thorough and perhaps uses `/deep-planning` automatically since the rules encourage detailed planning for critical code (maybe you wrote a rule for that). After agreeing on a plan, you switch to Act mode and Cline writes the code to fix the rounding issue. It uses your coding style from the rules (e.g. proper formatting) and mentions updating relevant docs (maybe because a rule said to update docs for major changes). After it writes the code, it automatically creates a checkpoint. You click Compare, see the diff looks good. You run tests – suppose one test fails. You use `@terminal` to show Cline the failing test output. Cline identifies a minor mistake and fixes it (another Act, another checkpoint).

* _Memory update:_ With the feature done, you tell Cline “_update memory bank_”. Because of either the MCP tool or the rules, Cline goes through each memory file and updates the content to reflect the new state (e.g. marks the payment rounding issue as resolved in `progress.md`, notes the approach in `systemPatterns.md`). All that context is now saved for future sessions[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=Memory%20Bank%20updates%20occur%20when%3A,When%20context%20needs%20clarification)[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=2,Impact%20assessment).

* _Workflow example:_ In the afternoon, you want to do a code review for a teammate’s PR. You invoke `/pr-review` workflow. Cline then executes the steps: it calls `gh` CLI to fetch PR info, uses `read_file` or `search_files` to open relevant diffs, asks you interactive questions (maybe “do you want me to approve or request changes?”), and drafts a review comment. This all happens in a structured way as per the workflow file. In 5 minutes, you’ve reviewed the PR with AI assistance that followed your company’s checklist, and you just had to give a couple of approvals in between steps[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=Real)[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=%60%60%60xml%20,Here%27s%20my%20justification).

* _Multi-tasking:_ Meanwhile, you get an urgent request to quickly verify something on the staging site. Instead of derailing your current chat, you hit `/newtask` to spawn a new session. Cline, following your custom new\_task rule, automatically summarizes the context (notes what you were doing)[docs.cline.bot](https://docs.cline.bot/exploring-clines-tools/new-task-tool#:~:text=,for%20Cline%20to%20suggest%20it) and maybe even notes “parking current work, switching to urgent task” in activeContext. In the new task, you connect to the remote browser and ask “_Check the homepage of staging, is the banner showing?_”. Cline opens the URL (via remote browser), maybe screenshots or just confirms the DOM, and gives you an answer. Once done, you can close that task, go back to your main task and continue where you left off – all memory preserved.

* _Wrap up:_ At end of day, you maybe run a `release.md` workflow to bump version and tag a release. Cline does it and even generates a draft release note from the commit history (if you made a workflow for that!). You update the Memory Bank, commit the memory bank files (since they’ve changed to reflect today’s progress), and push the code.

In this integrated setup, Cline is woven into your development lifecycle: it remembers context (Memory Bank), adheres to project conventions (Rules), automates repetitive chores (Workflows), brings in outside info (Mentions & Browser), and ensures safety (Checkpoints). As a developer, you still steer the ship – Cline always asks for confirmation on actions unless you’ve explicitly allowed them[datacamp.com](https://www.datacamp.com/tutorial/cline-ai#:~:text=extension%20%20,over%20changes%20to%20your%20workspace) – but much of the heavy lifting and busywork is handled by this AI co-pilot that’s customized to your project.

Finally, remember that these tools are meant to augment, not replace, your workflow. It’s wise to keep an eye on Cline’s outputs, review diffs, and use your judgment on its suggestions. With the configuration outlined above, Cline will be operating with a rich understanding of your project and preferences, which dramatically increases the relevance and correctness of its outputs. Many users find that after investing in setting up the Memory Bank and project rules, Cline’s assistance becomes markedly more “intuitive” and on-target for their needs[datacamp.com](https://www.datacamp.com/tutorial/cline-ai#:~:text=,implementation%20for%20better%20task%20management)[docs.cline.bot](https://docs.cline.bot/features/slash-commands/new-rule#:~:text=,side%20projects%20with%20all%20my). By following this guide, you’ve effectively configured Cline to be a persistent, context-aware, and workflow-savvy team member in your VS Code environment.

Having Cline set up in this way can truly feel like you have a capable junior developer who never forgets anything and works at superhuman speed – but still follows the senior developers’ guidelines. Happy coding with your new AI partner!

**Sources:** The descriptions and recommendations above were informed by the official Cline documentation and community resources, including the Memory Bank guide[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=What%20is%20the%20Cline%20Memory,Bank)[cline.bot](https://cline.bot/blog/memory-bank-how-to-make-cline-an-ai-agent-that-never-forgets#:~:text=Memory%20Bank%20is%20a%20community,settings%2C%20you%27re%20essentially%20telling%20it), Workflows documentation[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=Workflows%20allow%20you%20to%20define,name.md%5D%60%20in%20the%20chat), MCP server overview[docs.cline.bot](https://docs.cline.bot/mcp/mcp-overview#:~:text=Model%20Context%20Protocol%20is%20an,that%20an%20LLM%20can%20use), Cline Rules guide[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Cline%20Rules%20allow%20you%20to,or%20globally%20for%20every%20conversation), and practical insights from Cline’s developers on forums[reddit.com](https://www.reddit.com/r/CLine/comments/1mr2ixo/cline_v325_the_focus_chain_deepplanning_and_auto/#:~:text=Compact%20www,it%20back%20into%20context)[reddit.com](https://www.reddit.com/r/CLine/comments/1k7xb81/cline_v3133_release_smol_context_compression/#:~:text=,Cline%20summarizes%20the%20conversation%2C). These resources provide further reading and examples for each feature discussed.

![](https://www.google.com/s2/favicons?domain=https://www.reddit.com&sz=32)

![](https://www.google.com/s2/favicons?domain=https://cline.bot&sz=32)

![](https://www.google.com/s2/favicons?domain=https://docs.cline.bot&sz=32)

![](https://www.google.com/s2/favicons?domain=https://www.datacamp.com&sz=32)

Sources

---

ChatGPT Replied
----------------

Cline Mastery Guide for VS Code and Cursor Users

Fully Utilizing Cline: A Step-by-Step Developer Guide
=====================================================

Cline is a powerful AI coding assistant that goes far beyond autocomplete – it can maintain memory across sessions, follow custom workflows, integrate external tools, enforce coding rules, and more[datacamp.com](https://www.datacamp.com/tutorial/cline-ai#:~:text=The%20tool%20understands%20large%20codebases,through%20Ollama%20or%20LM%20Studio)[datacamp.com](https://www.datacamp.com/tutorial/cline-ai#:~:text=,implementation%20for%20better%20task%20management). This guide will show you how to fully leverage Cline in VS Code (or any VS Code-based IDE like Cursor), with a focus on **actionable implementation** of its major features. We’ll cover setting up a persistent Memory Bank, designing automated Workflows, configuring MCP servers for external tools, authoring persistent Cline Rules, and using additional tools (mentions, checkpoints, task commands, remote browsing) to create a cohesive AI development environment. The final section provides a project scaffold tying all these features together into a practical setup for beginners and advanced users alike.

Cline Memory Bank: Persistent Project Memory
--------------------------------------------

**Figure: Cline Memory Bank file structure.** _Core documentation files (e.g. `projectbrief.md`, `productContext.md`, `systemPatterns.md`, etc.) link together to form a persistent knowledge base for your project, which Cline reads and updates to “remember” context across sessions._[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=The%20Memory%20Bank%20is%20a,your%20project%20details%20over%20time)[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=Memory%20Bank%20files%20are%20simply,complete%20picture%20of%20your%20project)

One of Cline’s most powerful capabilities is its **Memory Bank**, a structured set of markdown files that serve as the assistant’s long-term memory. The Memory Bank transforms Cline from a stateless chat into a persistent development partner that can effectively “remember” project details over time[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=What%20is%20the%20Cline%20Memory,Bank)[datacamp.com](https://www.datacamp.com/tutorial/cline-ai#:~:text=,implementation%20for%20better%20task%20management). By preserving context between sessions, you don’t have to re-explain your project each day – Cline will rebuild its understanding from these files at the start of each task[cline.bot](https://cline.bot/blog/memory-bank-how-to-make-cline-an-ai-agent-that-never-forgets#:~:text=Memory%20Bank%20is%20a%20community,settings%2C%20you%27re%20essentially%20telling%20it).

### Setting Up the Memory Bank

The Memory Bank is simply a folder in your repository (usually named `memory-bank/`) containing a standard set of markdown files. Cline expects the following core files (it will create them on first use if they don’t exist[cline.bot](https://cline.bot/blog/memory-bank-how-to-make-cline-an-ai-agent-that-never-forgets#:~:text=%3E%20,to%20understand%20the%20project%20context)):

    your-project/
    ├── memory-bank/
    │   ├── projectbrief.md      # High-level project overview and goals
    │   ├── productContext.md    # The “why” of the project (problems, use cases)
    │   ├── systemPatterns.md    # Architecture, key technical decisions & patterns
    │   ├── techContext.md       # Tech stack, libraries, dev environment, constraints
    │   ├── activeContext.md     # Current focus, recent changes, and active decisions
    │   └── progress.md          # Progress status, remaining tasks, known issues

When starting a new project, you can initialize the memory bank structure using Cline’s tools. For example, if you install the **Memory Bank MCP server** (a community extension for Cline), you can run an init command to scaffold these files automatically[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=After%20installation%20and%20building%2C%20initialize,in%20the%20project%27s%20root%20directory):

    # Clone and build the Memory Bank server (community MCP extension)
    git clone https://github.com/dazeb/cline-mcp-memory-bank.git
    cd cline-mcp-memory-bank && pnpm install && pnpm run build

    # Initialize memory bank in your project (creates memory-bank/ files)
    node build/index.js initialize_memory_bank .

After running the init, you’ll find the `memory-bank/` folder populated with the core `.md` files (each containing some template sections). You can also have Cline initialize it by simply asking in chat: _“Initialize the memory bank for this project.”_ Cline will then create the folder and files, asking you for key project details to fill in[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=Alternatively%2C%20if%20the%20server%20is,initialize%20the%20memory%20bank). Once set up, the Memory Bank is seamlessly integrated – Cline will quietly use it in the background with no further configuration needed[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=,understand%20project%20evolution).

> **Tip:** The first time you use Memory Bank in a project, provide a **project brief** – a short description of what you’re building and its goals. Cline will use this as the foundation and start asking follow-up questions to flesh out the other files[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=First)[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=%2A%20Start%20simple%20,it%20as%20your%20project%20evolves). You can update any file later as the project evolves.

### Using and Maintaining the Memory Bank

**How it works:** At the **start of each new task**, Cline will read the memory bank files to load the project context[cline.bot](https://cline.bot/blog/memory-bank-how-to-make-cline-an-ai-agent-that-never-forgets#:~:text=%3E%20,to%20understand%20the%20project%20context). For example, it reads your `projectbrief.md` to recall the project scope, `productContext.md` for user requirements, `systemPatterns.md` for architecture, etc., then combines that knowledge into the conversation context. This allows Cline to “remember” prior decisions, designs, and progress when you resume work[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=The%20Memory%20Bank%20isn%E2%80%99t%20a,its%20understanding%20of%20your%20project)[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=CRITICAL%3A%20Before%20ANY%20task%20or,Open%20questions%20and%20concerns). Throughout development, Cline will also **update** the Memory Bank as needed – typically after significant changes or when you explicitly ask it to. It will document new insights, record decisions, and update the `activeContext.md` and `progress.md` files so they stay accurate[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=)[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=After%20EVERY%20task%3A%201,Changes%20made).

**When to update:** Cline automatically creates Memory Bank updates whenever you discover new patterns or complete major changes[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=Memory%20Bank%20updates%20occur%20when%3A,When%20context%20needs%20clarification)[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=Memory%20Bank%20updates%20should%20automatically,occur%20when). You can also manually trigger an update by saying “_update memory bank_” – Cline will then review _all_ memory files (particularly the active context and progress) and incorporate the latest information[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=Start%20)[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=,based%20on%20your%20current%20needs). Best practice is to update the memory bank at logical milestones (e.g. after implementing a feature or resolving a big bug) so that the next session starts with an up-to-date understanding of the project.

> **Best Practices:** Treat the Memory Bank as living documentation. Keep the files concise and high-value – focus on design decisions, why certain approaches were taken, current blockers, etc. This helps Cline give consistent, context-aware help. For example, regularly note what part of the project you’re working on in `activeContext.md` (e.g. _“Implementing user login API – last session completed DB schema for users.”_), and update `progress.md` to reflect completed items and new TODOs[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=,Records%20key%20technical%20decisions)[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=,complete%3B%20reporting%20not%20started%E2%80%9D). These files not only guide Cline, but double as useful docs for you and your team. Remember: after any context reset, the Memory Bank is Cline’s only link to prior work – _its accuracy determines Cline’s effectiveness_[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=Note%3A%20When%20triggered%20by%20,as%20they%20track%20current%20state).

With the Memory Bank in place, Cline will preserve context across sessions. You can close VS Code on Friday and on Monday Cline will recall exactly where you left off, who the stakeholders are, what the architecture is, etc., by reading those files – no repetitive explaining needed[cline.bot](https://cline.bot/blog/memory-bank-how-to-make-cline-an-ai-agent-that-never-forgets#:~:text=Here%27s%20the%20thing%20about%20AI,gets%20amnesia%20every%20coffee%20break)[cline.bot](https://cline.bot/blog/memory-bank-how-to-make-cline-an-ai-agent-that-never-forgets#:~:text=Memory%20Bank%20is%20a%20community,settings%2C%20you%27re%20essentially%20telling%20it). This persistent memory system enables continuity even with large projects that exceed the model’s token window.

### Example Memory Bank Entry

To illustrate, here’s a snippet of what an Memory Bank file might contain (as an example for a web app project):

    **Project Name:** Inventory Management System
    **Overview:** Internal web app for managing inventory across multiple warehouses in real time. Includes barcode scanning and analytics.

    **Core Requirements:**
    - Track stock levels across locations with real-time updates.
    - Provide a dashboard for low-stock alerts and restock suggestions.
    - Include a barcode scanner interface for scanning products.

    **Out of Scope:**
    - No e-commerce or payment processing (internal use only).

This could be part of `projectbrief.md`. Other files would cover things like key technical decisions (e.g. “Using Redux for state management” in `systemPatterns.md`[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=4.%20systemPatterns.md%20,md)) or current status (e.g. “User authentication module complete; Inventory CRUD API ~80% done; Reporting not started” in `progress.md`[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=,complete%3B%20reporting%20not%20started%E2%80%9D)). By filling in these files, you give Cline a structured summary of the project. Whenever you say “_follow the custom instructions_” or start a new task, Cline will ingest this info to ground its advice and code in your project’s reality[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=The%20Memory%20Bank%20isn%E2%80%99t%20a,its%20understanding%20of%20your%20project)[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=Where%20are%20the%20memory%20bank,files%20stored).

_(Cline Memory Bank is a community-driven feature – you can implement it via custom instructions or by installing an MCP server. For most users, the MCP route is easiest: after installation, the `memory-bank` tools (like `initialize_memory_bank`, `update_context`, etc.) become available in Cline[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=%22memory,%5B%5D%20%7D%20%7D)[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=use_mcp_tool%28%27memory,or%20specific%20path). The server handles reading/writing the files. Alternatively, advanced users can embed the memory logic in a `.clinerules` or custom instruction to achieve similar results[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=Should%20I%20use%20custom%20instructions,clinerules).)_

Workflows: Automating Multi-Step Tasks
--------------------------------------

Cline **Workflows** allow you to define a series of steps that Cline will execute to accomplish a repetitive or complex process[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=Workflows%20allow%20you%20to%20define,name.md%5D%60%20in%20the%20chat). Instead of manually guiding the AI through the same sequence of actions (like running tests, reviewing code, deploying, etc.), you can script those steps once in a markdown file. Then, any time you need to run that workflow, you simply invoke it with a slash command.

**How it works:** A workflow is defined by a markdown `.md` file (saved in a designated workflows directory, typically alongside your `.clinerules` folder) that lists instructions and commands for Cline to follow[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=Workflows%20live%20alongside%20Cline%20Rules,Creating%20one%20is%20straightforward). Each step can include text for the AI (“Ask AI”) and embedded code blocks or tool directives (like shell commands, file operations, or even other AI tool calls). To run a workflow, type `/[workflow-name]` in the Cline chat – for example, if you have `deploy-service.md`, type `/deploy-service`. Cline will load that file and step through the instructions. You can also pass parameters if your workflow is designed to accept them (Cline will prompt you for any required inputs when you trigger the workflow)[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=1,any%20required%20parameters%20when%20prompted).

**Workflow capabilities:** Within a workflow file, you can leverage all of Cline’s tools and even external commands:

* **Built-in tools:** You can use special XML-like tags to call Cline’s internal tools or prompt actions. For example, `<read_file>` to have Cline read a file’s content, `<search_files>` to search within files, or `<ask_followup_question>` to interact with the user during the workflow[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=The%20real%20power%20comes%20from,You%20can)[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=%60%60%60xml%20,options%3E%20%3C%2Fask_followup_question%3E). These let the workflow branch or get confirmation.

* **Command-line steps:** You can include shell commands (in fenced `bash` code blocks) to run system tools like build scripts, Docker, Git, etc. Cline will execute them in the integrated terminal as part of the workflow.

* **MCP tools or APIs:** If you have MCP servers connected (for example, a Slack notifier or a testing tool), the workflow can call them as well (via the same tool-calling syntax). This means workflows can reach out to external services or perform API calls as needed[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=%2A%20Leverage%20Cline%E2%80%99s%20built,together%20in%20a%20specific%20sequence).

* **Chaining actions:** The real power is sequencing these actions. A workflow can run tests, gather results, ask you a question based on those results, then continue or abort based on your answer – all in one invocation.

### Creating a Workflow

To create a new workflow, add a markdown file to your workflows directory (for a project-specific workflow, use a folder in your repo, e.g. `.clinerules/workflows/`; for global, there may be a global workflows folder). The file should contain a clear sequence of steps and any commands. For example, let’s create a simple workflow to **run tests and deploy a service**:

    # deploy-service.md

    Ask AI:
    You have access to the `npm` and `docker` CLI tools. This workflow will test the project and deploy the latest build if tests pass.

    ## 1. Run the Test Suite
    ```bash
    npm install
    npm test

2\. Build & Push Docker Image
-----------------------------

    docker build -t myapp:latest .
    docker push myrepo/myapp:latest

3\. Deployment Confirmation
---------------------------

<ask\_followup\_question>
<question>Tests passed and the image is pushed. Do you want to deploy to production?</question>
<options>\["Yes, deploy now", "No, deploy later"\]</options>
</ask\_followup\_question>

4\. Deploy (if confirmed)
-------------------------

    # This step runs only if user confirmed "Yes, deploy now"
    kubectl rollout restart deployment/myapp



    In this `deploy-service.md` workflow:

    - Step 1 installs dependencies and runs tests.
    - Step 2 builds a Docker image and pushes it to a registry.
    - Step 3 uses an `<ask_followup_question>` tool to ask the user whether to proceed with deployment (giving two buttons: “Yes, deploy now” or “No, deploy later”).
    - Step 4 (the deploy command) would only execute if the user confirmed in step 3.

    To run this workflow, you would type `/deploy-service` in Cline’s chat. Cline will execute each step in order. At step 3 it will pause and prompt you with the options, then continue based on your choice. This kind of automation can save a lot of time for common operations like deployments, PR reviews, etc. In fact, the Cline team provided a **PR review workflow** example that automates fetching a PR’s details, diff, analyzing changes, and even drafting a response:contentReference[oaicite:41]{index=41}:contentReference[oaicite:42]{index=42} – you can create similar flows for code reviews, environment setup, or anything you find yourself doing frequently.

    **Focus Chain:** In addition to custom workflows you define, Cline has an automatic planning aid called **Focus Chain** that keeps the AI on track during any complex task. When you give Cline a task, it can generate a numbered to-do list of subtasks and persist this list in the context:contentReference[oaicite:43]{index=43}. As each item is completed, it checks it off and moves to the next. This isn’t just a UI feature – the focus chain items remain in Cline’s working context so it remembers what remains to be done. Focus Chain essentially acts like an auto-generated mini-workflow for your current task, ensuring that even if the conversation is long, the AI doesn’t lose sight of the remaining steps. It complements your own workflows by structuring ad-hoc tasks methodically (think of it as Cline being a diligent project manager for every request):contentReference[oaicite:44]{index=44}. You don’t need to script anything to use Focus Chain – just be aware that Cline may produce this list when appropriate, and you can rely on it to navigate complex tasks step-by-step.

    **Workflow best practices:** Keep workflow files focused and deterministic. Test them out on a sample scenario to ensure they do what you expect. You can include comments or instructions to yourself in the markdown (Cline will generally ignore text that isn’t in a code block or a tool tag, or you can prefix lines with `<!-- -->` to comment out). Use the `Ask AI` preamble at top to set the scene for the workflow if needed (as shown in the example). Also, remember that workflows can call other workflows or tasks via the `new_task` tool (though this can get advanced). Start simple – even a 3-step workflow to “run build → open browser → run tests” can save you a ton of time over repeated manual prompting.

    Once you have a library of useful workflows, they will appear in Cline’s **Workflows tab** in the UI for easy reuse (ensure your files are in the correct folder so Cline can load them). Workflows empower you to chain Cline’s actions in a safe, reviewable way – you design the game plan, and Cline executes it precisely, asking for confirmation when needed. This leads to more consistent results especially for DevOps tasks or lengthy processes, since the AI doesn’t “forget” a step or get sidetracked.

    ## MCP Servers: Extending Cline with External Tools

    Modern development often requires going beyond code in your editor – you might need to query a database, fetch an API, run cloud commands, or use custom utilities. Cline addresses this via **MCP (Model Context Protocol) servers**, which are plugins that act as intermediaries between the AI and external tools or data sources:contentReference[oaicite:45]{index=45}. Think of MCP as *“a USB-C port for AI”*: a standardized way to plug capabilities into Cline:contentReference[oaicite:46]{index=46}. By adding MCP servers, you can greatly extend what Cline can do – from browsing the web to running specialized analyses – all from the VS Code interface.

    ### Configuration and Integration

    Out of the box, Cline doesn’t include specific MCP servers (for security and modularity reasons):contentReference[oaicite:47]{index=47}. You choose and install the ones you need:

    - **MCP Marketplace (One-click Install):** The easiest way is to use Cline’s built-in MCP Marketplace interface:contentReference[oaicite:48]{index=48}:contentReference[oaicite:49]{index=49}. In VS Code, click the Cline extension icon and go to the *Marketplace* or *Discover* section under MCP Servers. There you can browse hundreds of available servers by category (for example: “Search”, “Browser-automation”, “Code analysis”, etc.):contentReference[oaicite:50]{index=50}. With one click you can install a server; Cline will automatically download it, build it (if needed), and prompt you for any API keys or config (for instance, a server for web search might require a Bing API key):contentReference[oaicite:51]{index=51}:contentReference[oaicite:52]{index=52}. Once installed, it appears in your “Installed MCPs” list.

    - **Manual from GitHub:** You can also add servers from source. Many community-created MCP servers are listed in repositories like the *official Cline MCPs* or *Awesome MCP* list:contentReference[oaicite:53]{index=53}. If you have a GitHub URL, you can ask Cline to add it. For example: *“Cline, add the MCP server from `https://github.com/modelcontextprotocol/servers/.../brave-search`”* :contentReference[oaicite:54]{index=54}. Cline will clone the repo, detect if it needs building (e.g. sees a `package.json` and runs `npm run build`), and prompt you for any configuration (like an executable path or API key):contentReference[oaicite:55]{index=55}:contentReference[oaicite:56]{index=56}. It then updates your MCP settings to include this server. You can always configure the settings manually as well (in the JSON file `cline_mcp_settings.json`) but the guided approach is simpler.

    - **Custom Servers:** If you want to write your own MCP server (for a truly custom integration), Cline provides a development protocol and even a template. Essentially, an MCP server can be any program (Node, Python, etc.) that reads JSON requests from stdin and writes JSON responses (tools/resources) to stdout (for STDIO mode):contentReference[oaicite:57]{index=57}. You’d register it in the settings with the command to launch it. Covering MCP server development is beyond this guide, but know that if you have a special internal API or system, you can wrap it as an MCP server to let Cline use it.

    After installation, each MCP server will have an entry in your Cline settings. For example, here’s what a configuration might look like with one local server and one remote server:

    ```json
    {
      "mcpServers": {
        "my-local-tool": {
          "command": "python",
          "args": ["/Users/me/mcp-servers/my_tool.py"],
          "env": { "API_KEY": "<your_api_key>" },
          "disabled": false
        },
        "browser-agent": {
          "url": "https://myserver.com/mcp",
          "headers": { "Authorization": "Bearer <token>" },
          "disabled": false
        }
      }
    }

In this JSON, `"my-local-tool"` is a server that Cline will launch locally (via STDIO transport) by running the given Python script (with an environment variable set)[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=Ask%20AI). `"browser-agent"` is an example of a remote MCP server (using SSE transport) that Cline will connect to at the given URL[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=%7B%20%22mcpServers%22%3A%20%7B%20%22remote,false). Typically, you won’t edit JSON by hand thanks to the UI, but it’s useful to understand. Each server entry can also specify an `alwaysAllow` list of tool names (meaning those tools won’t prompt for approval each time)[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=%22memory,%5B%5D%20%7D)[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=,false%20%7D%20%7D), and you can toggle a server on/off or restart it from the VS Code interface easily[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=1,the%20MCP%20server%20config%20box)[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=Enabling%20or%20Disabling%20a%20Server).

### Using MCP Tools and Scaling Up

Once a server is running, Cline auto-discovers its tools and resources. You’ll notice in the system prompt (which you can view via the “MCP Inspector”) that the AI is now aware of new capabilities. To **use an MCP tool**, you usually just ask in natural language and Cline will decide to invoke it if appropriate. For instance, if you installed a “Web Search” MCP, you could ask: “_Search the web for the latest React docs_”. Cline will identify that the web search tool can fulfill this and prompt you: “**Allow tool:** search\_web? \[Yes/No\]\*\*”. Upon approval, it executes the tool and the result (web content) is fed back into the conversation. This general flow applies to any tool – Cline handles calling it, you just approve and then see the results.

You can also directly prompt usage by saying something like “_Use the Slack notifier to post a message..._” if such a tool exists, but usually the AI will offer when relevant. If you find yourself always approving a certain tool (say a linter) and trust it, you can add it to the `alwaysAllow` list in settings so it runs without asking[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=,false). On the other hand, for dangerous tools, keep them requiring manual approval (default).

**Transport considerations:** There are two ways MCP servers run: **STDIO** (local) and **SSE** (remote streaming). Local STDIO servers run as child processes on your machine, communicating via standard input/output – this gives low latency and no network dependency[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=STDIO%20Transport). Remote SSE servers communicate over HTTP streaming, which allows the server to be hosted elsewhere (or share among a team) and handle multiple clients, at the cost of a bit more latency and requiring network access[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=SSE%20Transport). For example, you might run a heavy-duty AI model as a remote MCP on a powerful server and have Cline connect to it from your laptop. Or an MCP that needs to be shared by a team (like an internal database query service) could be deployed and accessed via SSE. Cline supports both seamlessly – you saw the config examples above for each. Choose STDIO for simple local tools and SSE for services you want to scale or host centrally[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=Used%20for%20remote%20servers%20accessed,over%20HTTP%2FHTTPS)[docs.cline.bot](https://docs.cline.bot/mcp/configuring-mcp-servers#:~:text=%2A%20Communicates%20via%20Server,Requires%20network%20access).

**Examples of MCP servers:** The use cases are endless. Some popular ones include: a **browser automation** server (to control a browser and scrape or test webapps), a **GitHub assistant** (to create issues/PRs or monitor CI), a **database query** tool (so Cline can answer questions from your database), cloud CLIs (AWS, GCP operations via AI), or even creative ones like controlling a robot or IoT device from Cline. The Cline docs list examples like monitoring GitHub issues, posting tweets, fetching weather data, automating Jira tickets, generating documentation, etc.[docs.cline.bot](https://docs.cline.bot/mcp/mcp-overview#:~:text=The%20potential%20of%20MCP%20servers,MCP%20servers%20can%20be%20used)[docs.cline.bot](https://docs.cline.bot/mcp/mcp-overview#:~:text=,dependencies%20based%20on%20project%20requirements). Essentially, any task that can be scripted or API-ified can be turned into an MCP tool for Cline to use. By integrating the right MCP servers, you empower the AI to act as an agent in your development workflow, all under your supervision.

> **Security:** MCP servers run code on your behalf, so only install ones you trust or that are sandboxed. Cline isolates credentials in environment variables or config for MCPs so you don’t have to paste secrets into chat[docs.cline.bot](https://docs.cline.bot/mcp/mcp-overview#:~:text=tools%2C%20prompts%2C%20and%20resources.%20,Interactions%20require%20explicit%20user%20approval). Always review what an MCP tool is about to do – Cline will describe the action and ask approval unless you opted out. This way you maintain a human-in-the-loop control, preventing unwanted side-effects[datacamp.com](https://www.datacamp.com/tutorial/cline-ai#:~:text=extension%20%20,over%20changes%20to%20your%20workspace).

In summary, MCP servers greatly extend Cline’s reach. With minimal setup, you can have Cline running your custom scripts, accessing internal systems, or performing tasks that normally require leaving VS Code. This turns Cline into a hub that coordinates all your dev tools through natural language. For instance, you could say: “_Run the load tests on the staging server_” and behind the scenes Cline might invoke a remote MCP that triggers a Jenkins job or hits an API endpoint – returning the results to you. All without leaving your coding context.

Cline Rules: Customizing AI Behavior
------------------------------------

While Cline comes with sensible defaults, every project and developer has unique preferences. **Cline Rules** let you inject your own guidelines and instructions into Cline’s system prompt on a persistent basis[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Cline%20Rules%20allow%20you%20to,or%20globally%20for%20every%20conversation). They act like a set of “house rules” that Cline will _always_ follow for your projects, so you don’t have to repeat the same instructions in every conversation. For example, you might have rules about coding style, architectural conventions, or how to handle certain files – once defined, Cline will take them into account in all its suggestions.

### Creating and Managing Rules

Rules are stored as markdown files as well. You can maintain them globally or per-project:

* A **Global Rule** applies to all conversations (good for personal preferences that span projects). These live in your user’s Documents folder (e.g. `~/Documents/Cline/Rules/` on Mac/Linux, or `Documents\Cline\Rules\` on Windows by default)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=The%20location%20of%20your%20Global,Cline%2FRules%60%20on%20some%20systems).

* A **Workspace/Project Rule** applies only to a specific project. These live in a folder (or single file) named `.clinerules` in your project’s root[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Once%20you%20save%20the%20file%3A)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=your,%E2%94%9C%E2%94%80%E2%94%80%20docs%2F%20%E2%94%94%E2%94%80%E2%94%80). Cline will automatically detect and load rules from `.clinerules/` when you open that workspace.

You can create a new rule from Cline’s UI: open the _Rules_ tab in the sidebar and click the “+” to add a rule. This opens a new markdown file where you can write the rule content[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Creating%20a%20Rule). Alternatively, use the **`/newrule`** slash command to be guided through rule creation[docs.cline.bot](https://docs.cline.bot/features/slash-commands/new-rule#:~:text=Using%20the%20). The `/newrule` command is interactive – Cline will ask you questions about what preferences you want to set (e.g. “Do you prefer verbose or concise explanations?”, “What testing frameworks do you use?”, “Any specific coding style guidelines?”)[docs.cline.bot](https://docs.cline.bot/features/slash-commands/new-rule#:~:text=When%20you%20want%20Cline%20to,consistently%20follow%20certain%20guidelines). After answering, it will generate a structured markdown file encapsulating those preferences for you to review[docs.cline.bot](https://docs.cline.bot/features/slash-commands/new-rule#:~:text=,be%20loaded%20for%20future%20conversations). Once you confirm, it saves it in your `.clinerules` directory and it becomes active[docs.cline.bot](https://docs.cline.bot/features/slash-commands/new-rule#:~:text=,be%20loaded%20for%20future%20conversations).

A rule file is just Markdown text describing the guidelines. You can organize it with headings and lists for clarity (Cline will parse the content as part of its system prompt). Here’s an example **Project Rule** file:

    # Project Guidelines

    ## Architecture Patterns
    - Follow microservice principles; each service has its own database.
    - Use RESTful API design for all new services.
    - All significant architectural decisions must be documented in `/docs/architecture.md`.

    ## Coding Style
    - Use **4-space indentation** for Python, **2-space** for JavaScript.
    - Follow PEP8 for Python code and Airbnb style guide for JavaScript.
    - Prefer clear variable names over abbreviations.

    ## Error Handling
    - All API endpoints should return structured JSON errors with an `error_code`.
    - Log all exceptions on the server with stack trace for debugging.

    ## Testing Requirements
    - Write unit tests for every bug fix (to prevent regressions).
    - Aim for > 90% coverage on critical modules (e.g. auth, payments).
    - Use pytest for Python tests and Jest for JS, with meaningful test case names.

This rule file outlines various project-specific standards: architecture, style, error handling, testing. Once this is saved as (for example) `.clinerules/01-guidelines.md` in your repo, Cline will include these instructions for every task in that workspace. If you asked Cline to write a new module, it would now **know** to apply 4-space indentation for Python, log exceptions, write tests, etc., without you explicitly stating those every time. Essentially, Cline Rules give the AI persistent context about _how you want to work_[docs.cline.bot](https://docs.cline.bot/features/slash-commands/new-rule#:~:text=,your%20preferences%20in%20every%20conversation).

**How rules are applied:** Cline automatically combines all active rules into its system prompt. If you have multiple markdown files in `.clinerules/`, it will merge them (you can prefix filenames with numbers like `01-`, `02-` to enforce order, though it’s not usually needed)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=your,work%20%E2%94%9C%E2%94%80%E2%94%80%20src%2F%20%E2%94%94%E2%94%80%E2%94%80)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Cline%20automatically%20processes%20all%20Markdown,files%20in%20a%20logical%20sequence). Global rules (if any) are applied first, then workspace-specific rules override or add to them[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=To%20make%20managing%20both%20single,this%20popover%20allows%20you%20to). The rules essentially become a single chunk of text that the model sees before any user prompt, guiding its behavior. You can verify which rules are active by looking at the Cline Rules UI popover – it will list global and project rules currently in effect[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=,file%20or). You can also toggle rules on/off from that UI if you want to temporarily disable one[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=settings%29%20and%20workspace%20rules%20%28,files%20to%20an%20existing%20folder).

**Custom rule variants:** Cline supports not only a single `.clinerules` file but an entire **rules folder system** for advanced use. As shown above, you can have multiple files in `.clinerules/` addressing different concerns (coding, documentation, current sprint, etc.)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=your,work%20%E2%94%9C%E2%94%80%E2%94%80%20src%2F%20%E2%94%94%E2%94%80%E2%94%80). Furthermore, you can maintain a **rules bank** – a repository of rule files that aren’t all active at once, but you copy in as needed[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=your,specific%20rules). For example, you might have a set of rules for Client A and another for Client B. You keep them in `clinerules-bank/clients/`, and when working on Client A’s project you copy the relevant file into `.clinerules/` and remove/switch out others[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Ask%20AI)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=,b.md%20.clinerules). This approach (outlined in Cline’s docs) is optional, but it’s a neat way to handle _contextual rule sets_. The benefits of using a folder of modular rules include easier maintenance (edit one area without touching others) and contextual activation (only use rules that matter for the current context, reducing noise)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Benefits%20of%20the%20Folder%20Approach). In practice, many teams start with one rules file and then split it as it grows, or when needing to switch sets for different projects.

**Examples of rules:** You saw a coding guideline example. Other common rules might include: _“Always comment public functions with JSDoc format”_, _“Prefer functional programming style where possible”_, _“Never directly commit to main branch, always create a PR”_, or _“When in doubt, ask me before using an insecure function.”_ Essentially, anything you find yourself repeatedly telling the AI (“don’t use eval”, “use responsive design”, “we follow TDD”) belongs in a rule. Rules can also instruct Cline on how to use tools – for example, a memory bank integration rule might say: “Before any task, read the memory-bank files; after completing a task, update the memory-bank (especially activeContext.md and progress.md)”[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=Memory%20Bank%20Integration%20Rules%3A)[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=After%20EVERY%20task%3A%201,Changes%20made). This would ensure the AI always leverages the Memory Bank. Another advanced use is to tailor Cline’s behavior per _mode_ or _phase_ – for instance, you might have a rule that only applies during planning (Plan mode) versus coding (Act mode). Cline doesn’t have an explicit conditional rule syntax, but you can write guidance like “In Plan mode, do X; In Act mode, do Y”, and because the AI knows which mode it’s in, it will follow that.

**Maintaining rules:** Since rules are just markdown files, they can be put under version control with your project. This is great for teams – you can all agree on a `.clinerules` file so everyone’s Cline behaves consistently and follows the project conventions[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=1.%20Version%20Controlled%3A%20The%20,standards%20and%20practices%20in%20code). If a rule needs updating, you update the file and everyone gets the new guidance. For personal global rules, you might keep your own notes (these aren’t versioned by Cline, but you could manually back them up). Cline’s UI provides a quick way to toggle rules if needed – say you have a rule that is not relevant for a quick experiment, you can disable it temporarily from the chat popover instead of deleting it[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Managing%20Rules%20with%20the%20Toggleable,Popover)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=settings%29%20and%20workspace%20rules%20%28,files%20to%20an%20existing%20folder). This flexibility helps when context-switching between different coding styles or projects.

To summarize, **Cline Rules give you fine-grained control over the AI’s responses and decisions**. By encoding your best practices and preferences, you ensure the AI’s output aligns with your expectations. It’s like configuring the “coding style” and “project knowledge” knobs on the AI. Use `/newrule` to quickly spin up a new rules file, or edit the markdown directly. After investing some time in good rules, many users find Cline becomes a much more reliable and personalized coding partner[docs.cline.bot](https://docs.cline.bot/features/slash-commands/new-rule#:~:text=,side%20projects%20with%20all%20my)[docs.cline.bot](https://docs.cline.bot/features/slash-commands/new-rule#:~:text=our%20existing%20codebase.%20,indentation%2C%20arrow%20functions%20everywhere%2C%20and) – because it’s now effectively trained on _your_ way of working, not just generic best practices.

Additional Tools and Features
-----------------------------

This section covers several additional Cline features and commands that enhance your workflow: **@ mentions** for injecting context, **checkpoints** for versioning and undo, handy **slash commands** for task management, and **remote browser integration** for web tasks. These tools, when used together, make Cline a more efficient and safe assistant.

### @ Mentions: Injecting Files, Errors, and URLs into Chat

Instead of copying and pasting code or error messages into your prompt, Cline lets you reference them directly with **@ mentions**. When you type `@` in the chat box, a menu appears with options to insert a reference to various content[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=Image%3A%20%40%20Mentions%20Overview). The referenced content will be pulled in automatically so the AI can see it. Cline supports a rich set of mention types[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=Available%20%40%20Mentions):

* **File mentions:** Use `@/path/to/file` to include the full content of any file in your workspace[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=File%20Mentions%20Reference%20any%20file,terminal%20to%20share%20your%20recent). For example, `@/src/utils/helpers.py` will tell Cline to grab that file’s text. This is extremely useful for discussing specific code – Cline “sees” the entire file, not just a snippet, so it has the full context (imports, surrounding code, etc.)[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=File%20Mentions%20Reference%20any%20file,terminal%20to%20share%20your%20recent).

* **Folder mentions:** Use `@/path/to/folder/` (note the trailing slash) to include all files in a directory[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=File%20Mentions%20Reference%20any%20file,terminal%20to%20share%20your%20recent). Cline will include a summary or structured listing of the folder’s contents and possibly key content from each file. This helps when you need the AI to understand how multiple files relate.

* **Problem mentions:** `@problems` inserts the list of current errors/warnings from your VS Code Problems pane[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=perfect%20for%20understanding%20complex%20interactions,terminal%20to%20share%20your%20recent). This way, if you have a compilation or linter errors, you can just drop `@problems` into the chat and Cline will see all the error messages and file locations in one go. This is great for debugging – e.g. “_I’m getting these errors: @problems. How do I fix them?_”.

* **Terminal output mentions:** `@terminal` inserts the recent output from your integrated terminal[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=files,22%2024%20Git%20Mentions%20Reference). For instance, if you run your test suite and it fails, just type `@terminal` and Cline will get the entire log (with all the coloring and formatting preserved)[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=warnings%20in%20your%20workspace,referencing%20documentation%20or%20GitHub%20issues). This is far easier than copy-pasting multiple screenfuls of log. Cline can then analyze the failure or error trace you showed it.

* **Git mentions:** `@git-changes` will include the diff of your unstaged Git changes, and `@[commit-hash]` will include the diff and message of that specific commit[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=terminal%20output,webpage%20content%2C%20perfect%20for%20referencing). This is useful for code review assistance or understanding what changed. For example: “_Given the changes @git-changes, do tests need updating?_” – Cline can see exactly what code was modified.

* **URL mentions:** You can paste any URL after `@`, like `@https://example.com/docs/api` [docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=perfect%20for%20debugging%20build%20errors,webpage%20content%2C%20perfect%20for%20referencing). Cline will fetch the web page content and include it (note: this requires the **Remote Browser** support to be configured, which we’ll discuss below). With URL mentions, you can ask questions about documentation or StackOverflow pages by just referencing the link – no manual copy needed. For example: “_According to @<https://docs.python.org/3/library/itertools.html>, how does `itertools.groupby` work?_” – Cline will fetch that page’s content and answer based on it.

These mentions **preserve formatting and full context**. So error logs remain easy to read, code retains indentation, etc., in the AI’s view[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=1.%20Eliminating%20copy,complete%20picture%20of%20your%20problem)[docs.cline.bot](https://docs.cline.bot/features/at-mentions/terminal-mentions#:~:text=command%20results,I%20just%20ask). Under the hood, Cline detects the `@...` patterns and replaces them with the actual content (encapsulated in special XML tags like `<file>` or `<terminal_output>` to delineate them) before sending the prompt to the model[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=happening%20behind%20the%20scenes%3A)[docs.cline.bot](https://docs.cline.bot/features/at-mentions/terminal-mentions#:~:text=How%20It%20Works%20Under%20the,Hood). This means you don’t use up valuable time manually describing or copying things – Cline does it instantly and accurately.

**Use cases:** @ mentions shine in scenarios like these:

* **Debugging:** “_I get this stack trace: @terminal. Here’s the function that triggers it: @/app/payment.py. What is the cause of the error?_” – Cline sees both the error and the code together.

* **Code review assistance:** “_@git-changes_ – Summarize these changes and point out any potential issues.” Cline will read the diff and provide a review.

* **Understanding large codebase:** “_Can you explain how the request flow works in the server? The main router is @/server/index.js and controllers are in @/server/controllers/_”.\* – This gives Cline multiple files to chew on.

* **Referencing documentation:** “_The spec says X (see @<https://tools.ietf.org/html/rfc1234>). Implement the function accordingly._” – Cline can read the RFC text for exact details.

By combining multiple mentions, you can give Cline a **complete picture** of a problem with minimal effort. As the docs say: you can chain several mentions in one prompt to provide all relevant context at once[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=1.%20Eliminating%20copy,complete%20picture%20of%20your%20problem). For example:

> _“I'm seeing an issue when I submit the form. The console error is @terminal. The frontend code is @/web/Form.jsx and the backend endpoint is @/api/routes/form.js. I suspect it broke after commit @abc1234. What’s wrong?”_

In one message you included the error output, the frontend component, backend route, and the commit diff – Cline can correlate all those and diagnose the issue, whereas explaining in words would be much more tedious.

**Important:** For `@urls` to work, you need to have Remote Browser support enabled (Cline can’t access the internet by itself). We’ll cover that soon – essentially you’ll connect Cline to a headless browser or an MCP that can fetch web pages. If not configured, `@url` mentions will just show an error or do nothing.

Mentions are a simple feature but drastically improve efficiency. They **eliminate copy-paste**, preserve fidelity of information, and ensure Cline has the _exact_ context you see[docs.cline.bot](https://docs.cline.bot/features/at-mentions/overview#:~:text=Why%20%40%20Mentions%20Matter). Make liberal use of them – whenever you think “the AI probably needs to see this file or this error”, just throw in an `@mention`. It will make Cline’s answers more accurate and save tokens by not having to summarize things yourself.

### Checkpoints: Version Control for AI Actions

As you collaborate with Cline on coding tasks, the AI may create or modify many files. **Checkpoints** are Cline’s built-in version control mechanism that saves a snapshot of your workspace after each step it takes[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Checkpoints%20automatically%20save%20snapshots%20of,experiment%20confidently%20with%20your%20code). Every time Cline uses a tool that changes code – for example, it writes to a file or executes a refactoring – it creates a hidden checkpoint. This allows you to _roll back_ to an earlier state if something goes wrong, or compare what changed.

**How it works:** Under the hood, Cline’s extension maintains a shadow Git repository where it commits changes on each step[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Cline%20creates%20a%20checkpoint%20after,These%20checkpoints). You don’t see these commits in your main repo (it doesn’t touch your actual Git history), but Cline exposes them through the UI. After a task step runs, you’ll see a **“Compare”** button in the chat next to that message – clicking it shows a diff of what files were changed at that step[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Viewing%20Changes%20%26%20Restoring). You’ll also see a **“Restore”** button next to each step in the task history[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Viewing%20Changes%20%26%20Restoring). Clicking “Restore” gives you options:

* **Restore Task and Workspace:** This reverts both the conversation _and_ all files to the state they were at that point[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=To%20restore%20to%20a%20previous,point). It’s like jumping into a time machine – Cline will forget any messages after that point and your code changes after that point are undone. Use this if you went down a wrong path and want to undo both the code and the discussion context.

* **Restore Task Only:** This reverts the conversation state to that point, but keeps the files as they are[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=1,codebase%20while%20preserving%20task%20context). Use this if, for example, you liked the code changes Cline made but the conversation got confused – you want to retry explaining without losing the edits.

* **Restore Workspace Only:** This keeps the conversation as-is but restores the files to that checkpoint[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=1,codebase%20while%20preserving%20task%20context). Use this if Cline’s recent code changes were bad, and you want to undo them, but you don’t want to lose the flow of the chat (perhaps you want to explain the issue and try a different approach). This is a common scenario: “Oops, Cline messed up the file, let me undo the file changes and then guide it differently.”

These restore options allow for very flexible recovery. For instance, if Cline’s code solution was wrong, you might restore the code but keep the chat (so you can tell it why it was wrong). Or if the code is fine but you want to ask a new question starting from an earlier context, you can restore the task only.

Cline’s checkpoint system means using the AI **does not risk messing up your project** because you can always roll back. It encourages experimentation: you can let Cline attempt bold refactors or generate large boilerplate, and if it doesn’t work out, just restore to the previous version with a click[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Use%20Cases)[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Testing%20Different%20Approaches). This safety net is especially helpful in **Auto-Approve** mode (where you let Cline execute multiple steps without manual confirmation). If a series of changes turn out problematic, you can undo them via the checkpoints list[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Using%20Auto). Essentially, checkpoints bring the benefits of Git (versioning and diff) to every AI action, integrated seamlessly.

**Using checkpoints effectively:** After any non-trivial AI change, consider clicking _Compare_ to review the diff. This shows exactly what Cline did, so you can approve it (maybe even commit it to your real repo) or spot mistakes. If something is off, use _Restore Workspace_ to undo the changes file-wise, but maybe stay in the conversation to guide Cline. If the whole approach went astray, do _Restore Task and Workspace_ to basically rewind and try a different approach from that point[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Example%3A%20If%20Cline%20makes%20changes,to%20try%20a%20different%20approach). You can also abandon an experiment entirely by restoring back to before it started. Checkpoints are stored in VS Code’s global storage, not in your repo[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Deleting%20Checkpoints). If you want to clear them, there’s a _“Delete All History”_ option which will remove all checkpoints (and task history)[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Deleting%20Checkpoints) – use with caution.

One more advanced trick: Cline’s **Message Editing** feature leverages checkpoints. If you edit an earlier user message and resubmit it, Cline can restore to the checkpoint right before that message and then replay from there with the new prompt[medium.com](https://medium.com/@balajibal/dissecting-cline-cline-context-management-260aec3d84cb#:~:text=Dissecting%20Cline%20%E2%80%94%20Cline%20Context,like%20%E2%80%9Cundo%E2%80%9D%20or%20task%20restoration)[docs.cline.bot](https://docs.cline.bot/features/checkpoints#:~:text=Relationship%20with%20Message%20Editing). This effectively allows you to correct a mistake in your question and rerun the conversation without starting over completely. It’s another way checkpoints enable _“have your cake and eat it too”_ scenario – you can tweak the past and roll forward again.

Overall, **checkpoints give you confidence and control** when using Cline. You’re never stuck with what the AI did – you have a history of every change and the ability to revert easily[reddit.com](https://www.reddit.com/r/CLine/comments/1jkzh71/is_there_no_way_to_revert_back_to_previous_chats/#:~:text=Reddit%20www.reddit.com%20%20Yes%20,place%20in%20the%20task). This encourages you to use Cline more freely, knowing you can always undo or compare. It’s highly recommended to incorporate reviewing diffs and using restore options as a normal part of your Cline workflow. It will save you from manually cleaning up any AI mistakes and will make the collaboration much more transparent.

### Useful Slash Commands (`/newtask`, `/deep-planning`, `/smol`, etc.)

We’ve already touched on a few of Cline’s **slash commands**, which are quick actions you can invoke from the chat input (by typing `/<name>`). Here’s a rundown of the most useful ones for task and context management:

* **`/newtask`:** Instantly fork off a new task (conversation) from your current one, carrying over essential context. This is extremely useful when your current chat has become too large or you want to tackle a sub-problem separately[docs.cline.bot](https://docs.cline.bot/exploring-clines-tools/new-task-tool#:~:text=As%20a%20quick%20alternative%20to,process%20using%20a%20Slash%20Command). When you type `/newtask`, Cline will suggest creating a new task and usually auto-generate a summary of the current context to preload (it might list the objectives accomplished so far and remaining goals)[docs.cline.bot](https://docs.cline.bot/exploring-clines-tools/new-task-tool#:~:text=,for%20Cline%20to%20suggest%20it). Upon confirmation, it ends the current chat and starts a fresh one with that summary in place. From there you continue with a clear context window but none of the old irrelevant discussion. In effect, it’s like a manual context window reset with memory of what’s important. Use `/newtask` proactively when you sense the conversation is hitting token limits or getting confused by too much history – it helps **eliminate context window limitations** while preserving continuity[datacamp.com](https://www.datacamp.com/tutorial/cline-ai#:~:text=,planning%20from%20implementation%20for%20better). (We’ll see in the scaffold how memory bank + newtask can be used together to seamlessly continue work.)

* **`/deep-planning`:** This command triggers an in-depth, structured planning mode for a complex feature or problem. Cline will go into a multi-step procedure: it will thoroughly investigate the requirements, possibly ask you clarifying questions, outline a detailed plan, and only then proceed to execution[docs.cline.bot](https://docs.cline.bot/features/slash-commands/deep-planning#:~:text=When%20you%20use%20%2Fdeep,features%3A%20thorough%20investigation%2C%20discussion). It’s akin to telling a senior engineer “let’s really plan this out before coding.” When you run `/deep-planning Your request...`, Cline will treat it differently than a normal prompt – typically, it might produce a four-step analysis: _1)_ read relevant files and requirements, _2)_ discuss possible approaches, _3)_ propose an implementation plan, and _4)_ optionally start executing (or wait for approval)[docs.cline.bot](https://docs.cline.bot/features/slash-commands/deep-planning#:~:text=When%20you%20use%20%2Fdeep,features%3A%20thorough%20investigation%2C%20discussion). This is great for very tricky tasks where jumping straight into code could lead to false starts. **Plan & Act mode** is already built into Cline (as discussed earlier), but `/deep-planning` explicitly invokes a thorough planning cycle up front. Many users report that starting complex tasks with `/deep-planning` yields better results and more organized solutions[x.com](https://x.com/cline/status/1956485641090564254#:~:text=Cline%20,you%20start%20with%20perfect). Use it when you have a big feature or architecture change – it forces the AI to slow down and “think” more systematically, almost like writing a design doc first.

* **`/smol`:** This funnily-named command is all about **compressing the context**. It tells Cline to summarize the current conversation and important details into a compact form, effectively freeing up space in the context window[reddit.com](https://www.reddit.com/r/CLine/comments/1k7xb81/cline_v3133_release_smol_context_compression/#:~:text=,Cline%20summarizes%20the%20conversation%2C)[x.com](https://x.com/cline/status/1927868371053294036#:~:text=Cline%20,even%20with%20smaller%20context%20models). If you’ve been chatting with Cline for a while and the task history is long, you might notice it getting close to the model’s token limit or starting to forget older messages. Typing `/smol` will make Cline produce a condensed summary of the conversation so far (covering key points, decisions, and data) and replace the full history with that summary in-memory. In practical terms, after `/smol`, earlier messages may no longer be in the prompt, but their essence will be preserved in the summary that remains. This is very useful before continuing a long session, or before adding a new large chunk of context (like reading a big file). It’s essentially on-demand context window management. (The name comes from the idea of making the conversation “smaller”). Note: in newer versions, `/smol` might also be accessible via `/compact`. After running it, you can continue the task with plenty of headroom. This works nicely in combination with checkpoints – you might checkpoint (which happens anyway) then smol to compress. Many users love `/smol` as it “frees up your context window space by generating a comprehensive summary”[datacamp.com](https://www.datacamp.com/tutorial/cline-ai#:~:text=Cline%20AI%3A%20A%20Guide%20With,This%20makes%20context), allowing very long-running assistant sessions without starting from scratch.

* **`/newrule`:** We covered this in the Rules section – it launches an interactive flow to create a new rule file. It’s a quick way to teach Cline new preferences on the fly (e.g. if mid-project you realize you want to enforce a pattern, you can /newrule and add it). This is better than just telling Cline in conversation because the rule will persist for future tasks. The use cases and an example were discussed earlier.

* **Other slash commands:** Cline has a few more, like `/reportbug` (which packages logs and info to help report an issue to the Cline team – use it if you encounter a bug with the extension), and possibly provider-specific ones. But those above are the main ones you’ll use regularly for workflow control. There are also shortcut commands like “Plan” and “Act” buttons or slash toggles to switch modes (instead of clicking the UI) – these simply do the same mode switch for Plan & Act.

Using slash commands can streamline your interactions. For instance, it’s much faster to type `/newtask` or click the “branch” icon than to manually copy-paste a summary into a new chat. And commands like `/deep-planning` and `/smol` can significantly improve outcome quality and manage costs by ensuring context is handled optimally. As a developer, think of these commands as additional tools in your toolbox – they help manage **conversation state** just like Git manages code state, keeping everything organized and efficient.

### Remote Browser Support: Letting Cline Browse the Web

Cline can even venture outside your codebase: with **Remote Browser support**, it can load and interact with webpages. This feature is particularly handy for two scenarios:

1. **Including web documentation or examples via `@url` mentions:** If you reference a URL with `@`, Cline needs a way to fetch that page’s content. Remote Browser provides that capability by controlling a browser that can download the page (including handling authentication if needed).

2. **Automating web tasks or testing a web app:** You could instruct Cline to open your local dev server in a browser, click buttons, fill forms, and report results, much like an automated QA tester. Cline can capture screenshots or console logs through this as well[github.com](https://github.com/cline/cline#:~:text=cline%2Fcline%20,allowing%20him%20to%20fix).

**How to set it up:** Remote Browser works via a headless Chrome instance. You have a few options to enable it:

* **Connect to a local Chrome:** The simplest method introduced in Cline v3.10 is to use a running Chrome/Chromium on your machine with remote debugging enabled[reddit.com](https://www.reddit.com/r/CLine/comments/1jvcuv8/cline_310_released_connect_to_local_chrome/#:~:text=Cline%203,replaces%20the%20old%20sessionless). You would launch Chrome with a command like `chrome --remote-debugging-port=9222` (or in VS Code, use the Cline command to connect to Chrome). In Cline’s MCP settings, you configure the remote browser by pointing it to `http://localhost:9222` (the debug port). Once connected, Cline can instruct that Chrome to navigate pages and perform actions. This way, when you do `@http://...`, Cline actually uses Chrome to fetch the page and returns the text.

* **Use a Browser MCP server:** There are community MCP servers (like “Browser Use Server”) designed for browser automation[glama.ai](https://glama.ai/mcp/servers/@ztobs/cline-browser-use-mcp#:~:text=Browser%20Use%20Server%20,Browser%20Operations). These are basically programs (often using Puppeteer or Playwright) that Cline can send commands to (open URL, click selector, etc.). If you prefer, you can install one of those via MCP marketplace. For example, a “Brave Browser” MCP or a generic “Browser” MCP. They might require specifying the browser binary path (as we saw in the earlier GitHub example where it asked for the Brave executable path)[docs.cline.bot](https://docs.cline.bot/mcp/adding-mcp-servers-from-github#:~:text=Cline%3A%20,Where%27s%20your%20Brave%20browser%20executable). Once set, you essentially have a tool like `open_url` or similar that Cline will use under the hood for `@url`.

* **Remote session (enterprise):** In some setups, you might run the browser on a remote machine (for example, a testing environment) and Cline connects to it. The principle is the same (SSE connection to a service that drives the browser).

For most individual developers, connecting to your local Chrome is straightforward. In the Cline UI, find _Remote Browser_ (or it might appear when you do an @ mention of an URL for the first time, guiding you to set it up). After connecting, test it by referencing a simple site (like `@https://example.com`). Cline should fetch and include the page text.

**What Cline can do with the browser:** It’s not limited to just static pages. Because it has a controlled Chrome instance, it can simulate user interactions. For example, it could fill out a login form if you provide it the steps (assuming you’ve logged in in that Chrome or provided session cookies). It can scroll, click, and capture the DOM. In effect, Cline can perform tasks akin to a Selenium script, but directed by natural language or workflow. One could say: “_Open our local app and run through the signup flow._” With a properly configured browser tool, Cline could navigate to `http://localhost:3000`, input test data, press buttons, and perhaps catch errors or take a screenshot. This is an advanced use, but it shows how the AI can extend into integration testing territory. The Cline docs mention using remote browser for certain web development test cases where authentication tokens and cookies are needed – meaning you can leverage your logged-in browser session.

**Security note:** The browser controlled by Cline is still under your supervision – it will ask before performing actions if they’re not read-only. Fetching a page to read is usually auto-approved when you trigger it via @ mention (you implicitly allowed it by using the mention). But if a workflow or the AI tries to do something like form submission, you’d see a tool approval. Also, be mindful that if you let Cline access an authenticated session, it could technically perform any action you could on that site – so only do this with test accounts or when you trust the AI in that context. The human oversight is key: you decide what tasks to allow.

In summary, enabling Remote Browser support unlocks Cline’s ability to directly incorporate external web knowledge and perform web UI operations. It’s extremely useful for pulling in documentation as context (no more copy-pasting snippets of MDN or StackOverflow – just `@<url>` it). It also opens up creative possibilities like automated UI testing or scraping within your development workflow. If your work involves web development, definitely consider setting up the remote browser feature. It turns Cline into a kind of one-stop shop where it can not only manage your code but also verify your app in a browser, search the web for solutions, and more – all with your guidance and approval.

Bringing It All Together: Project Scaffold and Workflow Integration
-------------------------------------------------------------------

We’ve covered a lot of features – now let’s outline how you can integrate them all in a cohesive developer setup. The goal is to have a project environment where Cline’s memory, rules, workflows, and tools all complement each other to assist you effectively. Below is a **recommended scaffold** for a project repository and Cline configuration that puts everything in place:

    my-project/
    ├── memory-bank/                # Persistent AI memory for this project
    │   ├── projectbrief.md         # (Filled with project overview/goals)
    │   ├── productContext.md       # (Filled with problem statement, requirements)
    │   ├── systemPatterns.md       # (Architecture decisions and patterns)
    │   ├── techContext.md          # (Tech stack and setup details)
    │   ├── activeContext.md        # (Updated frequently with current focus)
    │   └── progress.md             # (Updated with milestones, status, issues)
    ├── .clinerules/                # Project-specific Cline rules
    │   ├── 01-guidelines.md        # Coding standards, architecture rules, etc.
    │   ├── 02-memory-bank.md       # (Optional) Rule telling Cline to use/update Memory Bank
    │   ├── 03-newtask-strategy.md  # (Optional) Rule for auto new_task triggers and context block format
    │   └── workflows/             # Directory for workflow files
    │       ├── pr-review.md        # Workflow to automate pull request reviews
    │       ├── deploy-service.md   # Workflow to test & deploy (from example above)
    │       └── ... other workflows ...
    ├── src/                       # Your source code (Python/JS/Java/etc.)
    │   └── ...
    ├── tests/                     # Your tests
    │   └── ...
    └── README.md                  # (Your standard project readme)

**Memory Bank:** In this scaffold, the `memory-bank/` folder is checked into source control (so teammates also benefit from the up-to-date docs). On day one of the project, you might manually write the `projectbrief.md` (or run the `initialize_memory_bank` tool to generate templates). As development proceeds, Cline will update these files. Team members can read them like living documentation. If a new dev joins, they can read `systemPatterns.md` to quickly grasp architecture, etc. And whenever someone starts a new Cline task on this project, they simply say “follow custom instructions” and Cline will ingest these files to get up to speed[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=The%20Memory%20Bank%20isn%E2%80%99t%20a,its%20understanding%20of%20your%20project).

**Cline Rules:** The `.clinerules/` directory holds markdown files that define how Cline should behave for this project. In `01-guidelines.md` you put things like code style, definition-of-done, whatever rules matter globally. In `02-memory-bank.md`, you could include the “Memory Bank integration rules” discussed earlier – for example, a rule that says: _“Before any response, always check memory://active/context, memory://project/context, etc. After every task, update the memory files.”_[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=Memory%20Bank%20Integration%20Rules%3A)[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=After%20EVERY%20task%3A%201,Changes%20made). This will reinforce the memory bank usage in case the AI needs reminding. In `03-newtask-strategy.md`, you might define when to automatically use `new_task` – e.g. _“If context >50% full, consider summarizing and starting a new task (handoff). Always carry over summary of Completed Work, Pending Tasks, and Known Bugs in the `<context>` of new\_task.”_ (This corresponds to implementing an automatic handoff workflow like what the New Task Tool documentation suggests[docs.cline.bot](https://docs.cline.bot/exploring-clines-tools/new-task-tool#:~:text=The%20Power%20of%20,Custom%20Workflows)[docs.cline.bot](https://docs.cline.bot/exploring-clines-tools/new-task-tool#:~:text=define%20the%20%60,comprehensive%20structure%20often%20includes)). These additional rule files are **optional** and more advanced – you could also just keep one `.clinerules` file. But splitting them out as shown makes it clear what each is for, and you can toggle them individually if needed. By placing this folder in the repo, all developers get the same rules loaded (ensuring consistency in AI behavior across the team)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=1.%20Version%20Controlled%3A%20The%20,standards%20and%20practices%20in%20code). Do note that each user will need to open the project in VS Code with Cline to use them – but once they do, Cline will automatically load these rules.

**Workflows:** As shown, we suggest keeping workflow files under `.clinerules/workflows/` for project-specific workflows. For example, `pr-review.md` could contain the PR review process steps (which might use company-specific tools or standards), `deploy-service.md` we demonstrated earlier, etc. These files can also be put under version control so they evolve with the project’s needs. Cline will detect them and list them in the Workflows UI. Developers can run them with a slash command or from the UI. You might also have a `new-dev-setup.md` workflow to onboard a new developer (installs dependencies, sets up env vars, runs a test, etc.), or a `release.md` workflow to cut a new release (bump version, update changelog, tag in git, etc.). By storing them here, you essentially build a library of automation that’s one command away within Cline. It’s like documenting your processes, but in an executable form.

**MCP Servers:** While MCP configurations are typically in user-specific settings (not in the repo), you should document in the project README or wiki which MCP servers are recommended for full functionality. For example, if this project relies on a “Database Query” MCP and a “Slack Notifier” MCP, note that so team members can install them. You might even include a snippet of the `cline_mcp_settings.json` in docs to show how to configure (though don’t commit actual API keys). In our scaffold, if memory bank MCP is used, each dev would install it locally (as it’s more of a personal setup). The `.clinerules/02-memory-bank.md` rule file ensures that whether or not the MCP is installed, Cline knows it should manage those files; if the MCP is present, it provides actual tool support (like `update_memory_bank` tool), otherwise Cline will do its best with just the instructions.

**Remote Browser:** Similar to MCP, each user enables this on their machine. As an integrator, you might include a note: “For full Cline usage, connect your browser (Chrome) via remote debugging on port 9222.” If your workflows involve any `@url` or web actions (say the `pr-review.md` could fetch a GitHub PR page content via URL mention), then having the remote browser configured is important. In a corporate setting, you might even run a dedicated remote browser MCP server that developers connect to (though usually local is fine). The key is to ensure everyone has the capability so that when they run the workflow or mention a URL, it works.

**Putting it in practice:** Here’s a scenario of how all pieces come together in day-to-day work:

* _Morning:_ You open the project in VS Code and start a new Cline chat: “_Cline, let’s continue the feature from yesterday._” Before answering, Cline reads the Memory Bank files (it sees in `activeContext.md` that you were implementing the payment integration and had an issue with currency conversion)[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=The%20Memory%20Bank%20isn%E2%80%99t%20a,its%20understanding%20of%20your%20project)[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=As%20you%20work%20with%20Cline%2C,less%20accurate%2C%20it%E2%80%99s%20time%20to). It also loads the project’s rules (so it knows your coding standards and to update memory bank later)[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Cline%20Rules%20allow%20you%20to,or%20globally%20for%20every%20conversation)[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=CRITICAL%3A%20Before%20ANY%20task%20or,Open%20questions%20and%20concerns). It greets you with a summary: “Good morning! Yesterday we were working on payment integration and identified an issue with currency conversion rounding. Our next step is to fix that in `PaymentService` (per activeContext). Let’s proceed in Plan mode.” This response is possible because of the persistent context provided by memory + rules.

* _Implementing a fix:_ You discuss the approach in Plan mode. Cline follows your rule to be thorough and perhaps uses `/deep-planning` automatically since the rules encourage detailed planning for critical code (maybe you wrote a rule for that). After agreeing on a plan, you switch to Act mode and Cline writes the code to fix the rounding issue. It uses your coding style from the rules (e.g. proper formatting) and mentions updating relevant docs (maybe because a rule said to update docs for major changes). After it writes the code, it automatically creates a checkpoint. You click Compare, see the diff looks good. You run tests – suppose one test fails. You use `@terminal` to show Cline the failing test output. Cline identifies a minor mistake and fixes it (another Act, another checkpoint).

* _Memory update:_ With the feature done, you tell Cline “_update memory bank_”. Because of either the MCP tool or the rules, Cline goes through each memory file and updates the content to reflect the new state (e.g. marks the payment rounding issue as resolved in `progress.md`, notes the approach in `systemPatterns.md`). All that context is now saved for future sessions[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=Memory%20Bank%20updates%20occur%20when%3A,When%20context%20needs%20clarification)[github.com](https://github.com/dazeb/cline-mcp-memory-bank#:~:text=2,Impact%20assessment).

* _Workflow example:_ In the afternoon, you want to do a code review for a teammate’s PR. You invoke `/pr-review` workflow. Cline then executes the steps: it calls `gh` CLI to fetch PR info, uses `read_file` or `search_files` to open relevant diffs, asks you interactive questions (maybe “do you want me to approve or request changes?”), and drafts a review comment. This all happens in a structured way as per the workflow file. In 5 minutes, you’ve reviewed the PR with AI assistance that followed your company’s checklist, and you just had to give a couple of approvals in between steps[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=Real)[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=%60%60%60xml%20,Here%27s%20my%20justification).

* _Multi-tasking:_ Meanwhile, you get an urgent request to quickly verify something on the staging site. Instead of derailing your current chat, you hit `/newtask` to spawn a new session. Cline, following your custom new\_task rule, automatically summarizes the context (notes what you were doing)[docs.cline.bot](https://docs.cline.bot/exploring-clines-tools/new-task-tool#:~:text=,for%20Cline%20to%20suggest%20it) and maybe even notes “parking current work, switching to urgent task” in activeContext. In the new task, you connect to the remote browser and ask “_Check the homepage of staging, is the banner showing?_”. Cline opens the URL (via remote browser), maybe screenshots or just confirms the DOM, and gives you an answer. Once done, you can close that task, go back to your main task and continue where you left off – all memory preserved.

* _Wrap up:_ At end of day, you maybe run a `release.md` workflow to bump version and tag a release. Cline does it and even generates a draft release note from the commit history (if you made a workflow for that!). You update the Memory Bank, commit the memory bank files (since they’ve changed to reflect today’s progress), and push the code.

In this integrated setup, Cline is woven into your development lifecycle: it remembers context (Memory Bank), adheres to project conventions (Rules), automates repetitive chores (Workflows), brings in outside info (Mentions & Browser), and ensures safety (Checkpoints). As a developer, you still steer the ship – Cline always asks for confirmation on actions unless you’ve explicitly allowed them[datacamp.com](https://www.datacamp.com/tutorial/cline-ai#:~:text=extension%20%20,over%20changes%20to%20your%20workspace) – but much of the heavy lifting and busywork is handled by this AI co-pilot that’s customized to your project.

Finally, remember that these tools are meant to augment, not replace, your workflow. It’s wise to keep an eye on Cline’s outputs, review diffs, and use your judgment on its suggestions. With the configuration outlined above, Cline will be operating with a rich understanding of your project and preferences, which dramatically increases the relevance and correctness of its outputs. Many users find that after investing in setting up the Memory Bank and project rules, Cline’s assistance becomes markedly more “intuitive” and on-target for their needs[datacamp.com](https://www.datacamp.com/tutorial/cline-ai#:~:text=,implementation%20for%20better%20task%20management)[docs.cline.bot](https://docs.cline.bot/features/slash-commands/new-rule#:~:text=,side%20projects%20with%20all%20my). By following this guide, you’ve effectively configured Cline to be a persistent, context-aware, and workflow-savvy team member in your VS Code environment.

Having Cline set up in this way can truly feel like you have a capable junior developer who never forgets anything and works at superhuman speed – but still follows the senior developers’ guidelines. Happy coding with your new AI partner!

**Sources:** The descriptions and recommendations above were informed by the official Cline documentation and community resources, including the Memory Bank guide[docs.cline.bot](https://docs.cline.bot/prompting/cline-memory-bank#:~:text=What%20is%20the%20Cline%20Memory,Bank)[cline.bot](https://cline.bot/blog/memory-bank-how-to-make-cline-an-ai-agent-that-never-forgets#:~:text=Memory%20Bank%20is%20a%20community,settings%2C%20you%27re%20essentially%20telling%20it), Workflows documentation[docs.cline.bot](https://docs.cline.bot/features/slash-commands/workflows#:~:text=Workflows%20allow%20you%20to%20define,name.md%5D%60%20in%20the%20chat), MCP server overview[docs.cline.bot](https://docs.cline.bot/mcp/mcp-overview#:~:text=Model%20Context%20Protocol%20is%20an,that%20an%20LLM%20can%20use), Cline Rules guide[docs.cline.bot](https://docs.cline.bot/features/cline-rules#:~:text=Cline%20Rules%20allow%20you%20to,or%20globally%20for%20every%20conversation), and practical insights from Cline’s developers on forums[reddit.com](https://www.reddit.com/r/CLine/comments/1mr2ixo/cline_v325_the_focus_chain_deepplanning_and_auto/#:~:text=Compact%20www,it%20back%20into%20context)[reddit.com](https://www.reddit.com/r/CLine/comments/1k7xb81/cline_v3133_release_smol_context_compression/#:~:text=,Cline%20summarizes%20the%20conversation%2C). These resources provide further reading and examples for each feature discussed.

![](https://www.google.com/s2/favicons?domain=https://www.reddit.com&sz=32)

![](https://www.google.com/s2/favicons?domain=https://cline.bot&sz=32)

![](https://www.google.com/s2/favicons?domain=https://docs.cline.bot&sz=32)

![](https://www.google.com/s2/favicons?domain=https://www.datacamp.com&sz=32)

Sources

---
